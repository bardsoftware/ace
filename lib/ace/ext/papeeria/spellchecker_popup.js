// Generated by CoffeeScript 1.12.6
(function() {
  var foo,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  foo = null;

  define(function(require, exports, module) {

    /*
    Few types used in this module:
    
    Correction
      caption: string
      value: string
      meta: string
      score: number
      action?(word: string)
    
    PopupAction
      caption: string
      doAction(word: string)
     */
    var Autocomplete, Spellchecker, SpellcheckerCompleter, actionAsCorrection, convertCorrectionList, mySpellchecker, mySpellcheckerPopup, setup;
    Autocomplete = require('ace/autocomplete');
    Spellchecker = require('ace/ext/papeeria/spellchecker');

    /*
    Convert an array of string to popup-eligible structure.
    @param {PopupAction} action -- action object to be prepended to the resulting list (or null)
    @param {Array<String>} corrections -- array of corrections
    @return {Array<Correction>}
     */
    convertCorrectionList = function(action, corrections) {
      var i, item, list;
      list = (function() {
        var j, len, results;
        results = [];
        for (i = j = 0, len = corrections.length; j < len; i = ++j) {
          item = corrections[i];
          results.push({
            caption: item,
            value: item,
            meta: "",
            score: corrections.length - i
          });
        }
        return results;
      })();
      list.unshift(actionAsCorrection(action));
      return list;
    };
    actionAsCorrection = function(action) {
      return {
        caption: action.caption,
        value: action.caption,
        meta: "",
        score: Number.MAX_VALUE,
        action: action.doAction
      };
    };
    mySpellcheckerPopup = null;
    mySpellchecker = null;

    /*
    Sets up spellchecker popup and implements some routines
    to work on current in the editor.
    @param {Editor} editor -- ace editor
    @param {(String, String) -> void} onReplaced -- callback taking typo and replacement
    @param {PopupAction} blacklistAction -- action to be applied if popup target is not a typo
    @param {PopupAction} whitelistAction -- action to be applied if popup target is a typo
     */
    setup = function(editor, onReplaced, blacklistAction, whitelistAction) {
      var command;
      mySpellcheckerPopup = new SpellcheckerCompleter(onReplaced, blacklistAction, whitelistAction);
      mySpellchecker = Spellchecker.getInstance();
      command = {
        name: "spellcheckerPopup",
        exec: function() {
          var ref;
          if ((ref = editor.completer) != null) {
            ref.detach();
          }
          editor.completer = mySpellcheckerPopup;
          return editor.completer.showPopup(editor);
        },
        bindKey: "Alt-Enter"
      };
      return editor.commands.addCommand(command);
    };
    SpellcheckerCompleter = (function(superClass) {
      extend(SpellcheckerCompleter, superClass);

      function SpellcheckerCompleter(onReplaced1, blacklistAction1, whitelistAction1) {
        this.onReplaced = onReplaced1;
        this.blacklistAction = blacklistAction1;
        this.whitelistAction = whitelistAction1;
        this.insertMatch = bind(this.insertMatch, this);
        this.gatherCompletions = bind(this.gatherCompletions, this);
        this.changeListener = bind(this.changeListener, this);
        SpellcheckerCompleter.__super__.constructor.call(this);
        this.isDisposable = true;
        this.typoRange = null;
        this.typo = null;
      }

      SpellcheckerCompleter.prototype.changeListener = function() {
        return this.detach();
      };

      SpellcheckerCompleter.prototype.gatherCompletions = function(editor, callback) {
        var column, ref, row, session;
        if (!mySpellchecker.isEnabled()) {
          callback(null, {
            finished: true
          });
          return true;
        }
        session = editor.getSession();
        ref = editor.getCursorPosition(), row = ref.row, column = ref.column;
        this.base = session.doc.createAnchor(row, column);
        this.typoRange = mySpellchecker.getTypoRange(row, column);
        this.typo = session.getTextRange(this.typoRange);
        if (mySpellchecker.isWordTypo(this.typo)) {
          mySpellchecker.getCorrections(this.typo, (function(_this) {
            return function(correctionsList) {
              return callback(null, {
                prefix: "",
                matches: convertCorrectionList(_this.whitelistAction, correctionsList),
                finished: true
              });
            };
          })(this));
        } else {
          callback(null, {
            prefix: "",
            matches: convertCorrectionList(this.blacklistAction, []),
            finished: true
          });
        }
        return true;
      };

      SpellcheckerCompleter.prototype.insertMatch = function(data, options) {
        var replacement;
        if (data == null) {
          data = this.popup.getData(this.popup.getRow());
        }
        if (data.action) {
          data.action(this.typo);
        } else {
          replacement = data.value || data;
          this.editor.getSession().replace(this.typoRange, replacement);
          this.onReplaced(this.typo, replacement);
        }
        return this.detach();
      };

      return SpellcheckerCompleter;

    })(Autocomplete.Autocomplete);
    return {
      setup: setup
    };
  });

}).call(this);
