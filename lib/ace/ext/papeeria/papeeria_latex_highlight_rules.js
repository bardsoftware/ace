// Generated by CoffeeScript 1.10.0
(function() {
  define(function(require, exports, module) {
    'use strict';
    var PapeeriaLatexHighlightRules, TextHighlightRules, oop;
    oop = require('../../lib/oop');
    TextHighlightRules = require('../../mode/text_highlight_rules').TextHighlightRules;
    PapeeriaLatexHighlightRules = function() {

      /**
      * We maintain a stack of nested LaTeX semantic types (e.g. "document", "section", "list"
      * to be able to provide context for autocompletion and other functions. 
      * Stack is constructed by the background highlighter;
      * its elements are then propagated to * the editor session and become 
      * available through getContext method.
      *
      * The exact semantics of the rules for the use described in the file tokenizer.js
      * @param {pushedState} string
      * @return {function} function, which correctly puts new type(pushedState) on stack
       */
      var EQUATION_STATE, EQUATIOТ_REGEX, LIST_REGEX, LIST_STATE, basicRules, beginRule, endRule, key, popState, pushState, rule;
      pushState = function(pushedState) {
        return function(currentState, stack) {
          if (currentState === 'start') {
            stack.push(currentState, pushedState);
          } else {
            stack.push(pushedState);
          }
          return pushedState;
        };
      };
      popState = function(currentState, stack) {
        return stack.pop() || 'start';
      };
      basicRules = [
        {
          token: 'comment',
          regex: '%.*$'
        }, {
          token: ['keyword', 'lparen', 'variable.parameter', 'rparen', 'lparen', 'storage.type', 'rparen'],
          regex: '(\\\\(?:documentclass|usepackage|input))(?:(\\[)([^\\]]*)(\\]))?({)([^}]*)(})'
        }, {
          token: ['storage.type', 'lparen', 'variable.parameter', 'rparen'],
          regex: '(\\\\(?:begin|end))({)(\\w*)(})'
        }, {
          token: ['keyword', 'lparen', 'variable.parameter', 'rparen'],
          regex: '(\\\\(?:label|v?ref|cite(?:[^{]*)))(?:({)([^}]*)(}))?'
        }, {
          token: 'storage.type',
          regex: '\\\\[a-zA-Z]+'
        }, {
          token: 'lparen',
          regex: '[[({]'
        }, {
          token: 'rparen',
          regex: '[\\])}]'
        }, {
          token: 'constant.character.escape',
          regex: '\\\\[^a-zA-Z]?'
        }
      ];
      LIST_REGEX = 'itemize|enumerate';
      EQUATIOТ_REGEX = 'equation|equation\\*';
      LIST_STATE = 'list';
      EQUATION_STATE = 'equation';
      beginRule = function(text, pushedState) {
        if (text == null) {
          text = '\\w*';
        }
        if (pushedState == null) {
          pushedState = 'start';
        }
        return {
          token: ['storage.type', 'lparen', 'variable.parameter', 'rparen'],
          regex: '(\\\\(?:begin))({)(' + text + ')(})',
          next: pushState(pushedState)
        };
      };
      endRule = function(text) {
        if (text == null) {
          text = '\\w*';
        }
        return {
          token: ['storage.type', 'lparen', 'variable.parameter', 'rparen'],
          regex: '(\\\\(?:end))({)(' + text + ')(})',
          next: popState
        };
      };
      this.$rules = {
        'start': [beginRule(LIST_REGEX, LIST_STATE), beginRule(EQUATIOТ_REGEX, EQUATION_STATE), endRule(EQUATIOТ_REGEX), endRule(LIST_REGEX)],
        EQUATION_STATE: [beginRule(EQUATIOТ_REGEX, EQUATION_STATE), beginRule(LIST_REGEX, LIST_STATE), endRule(EQUATIOТ_REGEX), endRule(LIST_REGEX)],
        LIST_STATE: [beginRule(LIST_REGEX, LIST_STATE), beginRule(EQUATIOТ_REGEX, EQUATION_STATE), endRule(EQUATIOТ_REGEX), endRule(LIST_REGEX)]
      };
      for (key in this.$rules) {
        for (rule in basicRules) {
          this.$rules[key].push(basicRules[rule]);
        }
      }
    };
    oop.inherits(PapeeriaLatexHighlightRules, TextHighlightRules);
    exports.PapeeriaLatexHighlightRules = PapeeriaLatexHighlightRules;
  });

}).call(this);
