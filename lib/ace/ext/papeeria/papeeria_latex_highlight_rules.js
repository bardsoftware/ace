// Generated by CoffeeScript 1.10.0
(function() {
  define(function(require, exports, module) {
    'use strict';
    var PapeeriaLatexHighlightRules, TextHighlightRules, oop;
    oop = require('../../lib/oop');
    TextHighlightRules = require('../../mode/text_highlight_rules').TextHighlightRules;
    PapeeriaLatexHighlightRules = function() {

      /**
      * We maintain a stack of nested LaTeX semantic types (e.g. "document", "section", "list" to be able to provide context for 
      * autocompletion and other functions. 
      * Stack is constructed by the background highlighter;
      * its elements are then propagated to * the editor session and become 
      * available through getContext method.
      
      * @param {destination} string
      * @return {function} function, which correctly puts new type(destination) on stack
       */
      var basicRules, beginRule, endRule, key, popState, pushState, rule;
      pushState = function(destination) {
        return function(currentState, stack) {
          if (currentState === 'start') {
            stack.push(currentState, destination);
          } else {
            stack.push(destination);
          }
          return destination;
        };
      };
      popState = function(currentState, stack) {
        return stack.pop() || 'start';
      };
      basicRules = [
        {
          token: 'comment',
          regex: '%.*$'
        }, {
          token: ['keyword', 'lparen', 'variable.parameter', 'rparen', 'lparen', 'storage.type', 'rparen'],
          regex: '(\\\\(?:documentclass|usepackage|input))(?:(\\[)([^\\]]*)(\\]))?({)([^}]*)(})'
        }, {
          token: ['storage.type', 'lparen', 'variable.parameter', 'rparen'],
          regex: '(\\\\(?:begin|end))({)(\\w*)(})'
        }, {
          token: ['keyword', 'lparen', 'variable.parameter', 'rparen'],
          regex: '(\\\\(?:label|v?ref|cite(?:[^{]*)))(?:({)([^}]*)(}))?'
        }, {
          token: 'storage.type',
          regex: '\\\\[a-zA-Z]+'
        }, {
          token: 'lparen',
          regex: '[[({]'
        }, {
          token: 'rparen',
          regex: '[\\])}]'
        }, {
          token: 'constant.character.escape',
          regex: '\\\\[^a-zA-Z]?'
        }
      ];
      beginRule = function(text, destination) {
        if (text == null) {
          text = '\\w*';
        }
        if (destination == null) {
          destination = 'start';
        }
        return {
          token: ['storage.type', 'lparen', 'variable.parameter', 'rparen'],
          regex: '(\\\\(?:begin))({)(' + text + ')(})',
          next: pushState(destination)
        };
      };
      endRule = function(text) {
        if (text == null) {
          text = '\\w*';
        }
        return {
          token: ['storage.type', 'lparen', 'variable.parameter', 'rparen'],
          regex: '(\\\\(?:end))({)(' + text + ')(})',
          next: popState
        };
      };
      this.$rules = {
        'start': [beginRule('itemize|enumerate', 'list'), beginRule('equation|equation\\*', 'equation'), endRule('equation|equation\\*'), endRule("itemize|enumerate")],
        'equation': [beginRule('equation|equation\\*', 'equation'), beginRule('itemize|enumerate', 'list'), endRule('equation|equation\\*'), endRule("itemize|enumerate")],
        'list': [beginRule('itemize|enumerate', 'list'), beginRule('equation|equation\\*', 'equation'), endRule('equation|equation\\*'), endRule("itemize|enumerate")]
      };
      for (key in this.$rules) {
        for (rule in basicRules) {
          this.$rules[key].push(basicRules[rule]);
        }
      }
    };
    oop.inherits(PapeeriaLatexHighlightRules, TextHighlightRules);
    exports.PapeeriaLatexHighlightRules = PapeeriaLatexHighlightRules;
  });

}).call(this);
