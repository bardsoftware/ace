// Generated by CoffeeScript 1.10.0
(function() {
  define(function(require, exports, module) {
    var ConstrainedTokenIterator, EquationRangeHandler, LatexParsingContext, Range, TokenIterator, findSurroundingBrackets;
    LatexParsingContext = require("ace/ext/papeeria/latex_parsing_context");
    TokenIterator = require("ace/token_iterator").TokenIterator;
    Range = require("ace/range").Range;
    findSurroundingBrackets = require("ace/ext/papeeria/highlighter").findSurroundingBrackets;
    ConstrainedTokenIterator = (function() {
      function ConstrainedTokenIterator(session1, range1, row, column) {
        this.session = session1;
        this.range = range1;
        this.tokenIterator = new TokenIterator(this.session, row, column);
        this.expired = !this.range.contains(row, column);
      }

      ConstrainedTokenIterator.prototype.getCurrentToken = function() {
        if (!this.expired) {
          return this.tokenIterator.getCurrentToken();
        } else {
          return null;
        }
      };

      ConstrainedTokenIterator.prototype.getCurrentTokenPosition = function() {
        if (!this.expired) {
          return this.tokenIterator.getCurrentTokenPosition();
        } else {
          return null;
        }
      };

      ConstrainedTokenIterator.prototype.stepBackward = function() {
        var curToken, ref, tokenColumn, tokenRange, tokenRow;
        this.tokenIterator.stepBackward();
        curToken = this.tokenIterator.getCurrentToken();
        if (curToken == null) {
          this.expired = true;
          return null;
        }
        ref = this.tokenIterator.getCurrentTokenPosition(), tokenRow = ref.row, tokenColumn = ref.column;
        tokenRange = new Range(tokenRow, tokenColumn, tokenRow, tokenColumn + curToken.value.length);
        if (this.range.containsRange(tokenRange)) {
          this.expired = false;
          return curToken;
        } else {
          this.expired = true;
          return null;
        }
      };

      ConstrainedTokenIterator.prototype.stepForward = function() {
        var curToken, ref, tokenColumn, tokenRange, tokenRow;
        this.tokenIterator.stepForward();
        curToken = this.tokenIterator.getCurrentToken();
        if (curToken == null) {
          this.expired = true;
          return null;
        }
        ref = this.tokenIterator.getCurrentTokenPosition(), tokenRow = ref.row, tokenColumn = ref.column;
        tokenRange = new Range(tokenRow, tokenColumn, tokenRow, tokenColumn + curToken.value.length);
        if (this.range.containsRange(tokenRange)) {
          this.expired = false;
          return curToken;
        } else {
          this.expired = true;
          return null;
        }
      };

      ConstrainedTokenIterator.prototype.stepTo = function(row, column) {
        this.tokenIterator = new TokenIterator(this.session, row, column);
        return this.expired = !this.range.contains(row, column);
      };

      return ConstrainedTokenIterator;

    })();
    EquationRangeHandler = (function() {
      EquationRangeHandler.BEGIN_EQUATION_TOKEN_SEQUENCE = [
        {
          type: "storage.type",
          value: "\\begin"
        }, {
          type: "lparen",
          value: "{"
        }, {
          type: "variable.parameter",
          value: "equation"
        }, {
          type: "rparen",
          value: "}"
        }
      ];

      EquationRangeHandler.END_EQUATION_TOKEN_SEQUENCE = [
        {
          type: "storage.type",
          value: "\\end"
        }, {
          type: "lparen",
          value: "{"
        }, {
          type: "variable.parameter",
          value: "equation"
        }, {
          type: "rparen",
          value: "}"
        }
      ];

      function EquationRangeHandler(editor1) {
        this.editor = editor1;
      }

      EquationRangeHandler.equalTokens = function(token1, token2) {
        return token1.type === token2.type && token1.value === token2.value;
      };

      EquationRangeHandler.prototype.getEquationStart = function(tokenIterator) {
        var curEquationStart, curSequenceIndex, curTokenPosition, j, len, ref, token;
        if (tokenIterator.getCurrentToken() == null) {
          tokenIterator.stepForward();
        }
        ref = EquationRangeHandler.BEGIN_EQUATION_TOKEN_SEQUENCE;
        for (j = 0, len = ref.length; j < len; j++) {
          token = ref[j];
          if (EquationRangeHandler.equalTokens(token, tokenIterator.getCurrentToken())) {
            tokenIterator.stepForward();
          }
        }
        curSequenceIndex = EquationRangeHandler.BEGIN_EQUATION_TOKEN_SEQUENCE.length - 1;
        curEquationStart = null;
        while (curSequenceIndex >= 0) {
          if (EquationRangeHandler.equalTokens(EquationRangeHandler.BEGIN_EQUATION_TOKEN_SEQUENCE[curSequenceIndex], tokenIterator.stepBackward())) {
            if (curSequenceIndex === EquationRangeHandler.BEGIN_EQUATION_TOKEN_SEQUENCE.length - 1) {
              curTokenPosition = tokenIterator.getCurrentTokenPosition();
              curEquationStart = {
                row: curTokenPosition.row,
                column: curTokenPosition.column + tokenIterator.getCurrentToken().value.length
              };
            }
            curSequenceIndex -= 1;
          } else {
            curSequenceIndex = EquationRangeHandler.BEGIN_EQUATION_TOKEN_SEQUENCE.length - 1;
            curEquationStart = null;
          }
        }
        return curEquationStart;
      };

      EquationRangeHandler.prototype.getEquationEnd = function(tokenIterator) {
        var curEquationStart, curSequenceIndex, j, len, ref, token;
        if (tokenIterator.getCurrentToken() == null) {
          tokenIterator.stepBackward();
        }
        ref = EquationRangeHandler.END_EQUATION_TOKEN_SEQUENCE.slice(0).reverse();
        for (j = 0, len = ref.length; j < len; j++) {
          token = ref[j];
          if (EquationRangeHandler.equalTokens(token, tokenIterator.getCurrentToken())) {
            tokenIterator.stepBackward();
          }
        }
        curSequenceIndex = 0;
        curEquationStart = null;
        while (curSequenceIndex < EquationRangeHandler.END_EQUATION_TOKEN_SEQUENCE.length) {
          if (EquationRangeHandler.equalTokens(EquationRangeHandler.END_EQUATION_TOKEN_SEQUENCE[curSequenceIndex], tokenIterator.stepForward())) {
            if (curSequenceIndex === 0) {
              curEquationStart = tokenIterator.getCurrentTokenPosition();
            }
            curSequenceIndex += 1;
          } else {
            curSequenceIndex = 0;
            curEquationStart = null;
          }
        }
        return curEquationStart;
      };

      EquationRangeHandler.prototype.getEquationRange = function(row, column) {
        var end, start, tokenIterator;
        tokenIterator = new TokenIterator(this.editor.getSession(), row, column);
        end = this.getEquationEnd(tokenIterator);
        start = this.getEquationStart(tokenIterator);
        return new Range(start.row, start.column, end.row, end.column);
      };

      return EquationRangeHandler;

    })();
    exports.EquationRangeHandler = EquationRangeHandler;
    exports.setupPreviewer = function(editor, popoverHandler) {
      var ContextHandler, KATEX_OPTIONS, SelectionHandler, ch, equationRangeHandler, getFormulaElement, initKaTeX, jqEditorContainer, katex, sh;
      katex = null;
      if (popoverHandler == null) {
        popoverHandler = {
          options: {
            html: true,
            placement: "bottom",
            trigger: "manual",
            container: editor.container
          },
          show: function(jqPopoverContainer, title, content, position) {
            jqPopoverContainer.css(position);
            popoverHandler.options.content = content;
            popoverHandler.options.title = title;
            jqPopoverContainer.popover(popoverHandler.options);
            jqPopoverContainer.popover("show");
          },
          destroy: function(jqPopoverContainer) {
            return jqPopoverContainer.popover("destroy");
          },
          popoverExists: function(jqPopoverContainer) {
            var ref;
            return ((ref = jqPopoverContainer.data()) != null ? ref.popover : void 0) != null;
          },
          setContent: function(jqPopoverContainer, title, content) {
            var popoverElement;
            popoverElement = jqPopoverContainer.data().popover.tip();
            popoverElement.children(".popover-content").html(content);
            return popoverElement.children(".popover-title").text(title);
          },
          setPosition: function(jqPopoverContainer, position) {
            return jqPopoverContainer.data().popover.tip().css(position);
          }
        };
      }
      initKaTeX = function(onLoaded) {
        var cssDemoPath, linkDemo, span;
        cssDemoPath = require.toUrl("./katex-demo.css");
        linkDemo = $("<link>").attr({
          rel: "stylesheet",
          href: cssDemoPath
        });
        $("head").append(linkDemo);
        span = $("<span>").attr({
          id: "formula"
        });
        $("body").append(span);
        require(["ace/ext/katex"], function(katexInner) {
          katex = katexInner;
          onLoaded();
        });
      };
      jqEditorContainer = $(editor.container);
      getFormulaElement = function() {
        return $("#formula");
      };
      KATEX_OPTIONS = {
        displayMode: true,
        throwOnError: false
      };
      equationRangeHandler = new EquationRangeHandler(editor);
      ch = ContextHandler = {
        contextPreviewExists: false,
        UPDATE_DELAY: 1000,
        LABEL_SEQUENCE: [
          {
            type: "keyword",
            value: /^\\label$/
          }, {
            type: "lparen",
            value: /^\{$/
          }, {
            type: "variable.parameter",
            value: /.*/
          }, {
            type: "rparen",
            value: /^\}$/
          }
        ],
        LABEL_PARAMETER_INDEX: 2,
        getMacrosArgumentRange: function(session, argumentStartPos) {
          var argumentRange;
          argumentRange = findSurroundingBrackets(session, argumentStartPos);
          if (argumentRange.mismatch) {
            return null;
          } else {
            return new Range(argumentRange.start.row, argumentRange.start.column + 1, argumentRange.end.row, argumentRange.end.column);
          }
        },
        getWholeEquation: function(tokenIterator) {
          var acceptToken, argumentRange, bracketPosition, curLabelParameter, curLabelTokens, curLine, labelParameters, labelSequenceIndex, range, session, token, tokenPosition, tokenValues;
          tokenValues = [];
          labelSequenceIndex = 0;
          labelParameters = [];
          curLabelParameter = null;
          curLabelTokens = [];
          session = editor.getSession();
          range = tokenIterator.range;
          token = tokenIterator.getCurrentToken();
          tokenPosition = tokenIterator.getCurrentTokenPosition();
          while (token != null) {
            acceptToken = true;
            if (token.type === "storage.type" && token.value === "\\label") {
              curLine = session.getLine(tokenPosition.row);
              bracketPosition = tokenPosition.column + "\\label".length;
              if (curLine[bracketPosition] === "{") {
                argumentRange = ch.getMacrosArgumentRange(session, {
                  row: tokenPosition.row,
                  column: bracketPosition + 1
                });
                if (argumentRange != null) {
                  acceptToken = false;
                  labelParameters.push(session.getTextRange(argumentRange));
                  tokenIterator.stepTo(argumentRange.end.row, argumentRange.end.column + 1);
                }
              }
            }
            if (acceptToken) {
              tokenValues.push(token.value);
            }
            tokenIterator.stepForward();
            token = tokenIterator.getCurrentToken();
            tokenPosition = tokenIterator.getCurrentTokenPosition();
          }
          return [labelParameters, tokenValues.join("")];
        },
        getPopoverPosition: function(row) {
          return {
            top: (editor.renderer.textToScreenCoordinates(row + 2, 1).pageY) + "px",
            left: (jqEditorContainer.position().left) + "px"
          };
        },
        getCurrentFormula: function() {
          var e, equationString, error, labelParameters, ref, ref1, startColumn, startRow, title, tokenIterator;
          try {
            ref = ch.curRange.start, startRow = ref.row, startColumn = ref.column;
            tokenIterator = new ConstrainedTokenIterator(editor.getSession(), ch.curRange, startRow, startColumn);
            tokenIterator.stepForward();
            ref1 = ch.getWholeEquation(tokenIterator), labelParameters = ref1[0], equationString = ref1[1];
            title = labelParameters.length === 0 ? "Formula" : labelParameters.join(", ");
            return [title, katex.renderToString(equationString, KATEX_OPTIONS)];
          } catch (error) {
            e = error;
            return ["Error!", e];
          }
        },
        initPopover: function() {
          return setTimeout((function() {
            var popoverPosition, ref, rendered, title;
            popoverPosition = ch.getPopoverPosition(ch.getEquationEnd());
            ref = ch.getCurrentFormula(), title = ref[0], rendered = ref[1];
            return popoverHandler.show(getFormulaElement(), title, rendered, popoverPosition);
          }), 0);
        },
        getEquationEnd: function() {
          var i;
          i = editor.getCursorPosition().row;
          while (LatexParsingContext.getContext(editor.getSession(), i) === "equation") {
            i += 1;
          }
          return i;
        },
        updatePosition: function() {
          return popoverHandler.setPosition(getFormulaElement(), ch.getPopoverPosition(ch.getEquationEnd()));
        },
        updateRange: function() {
          var cursorColumn, cursorRow, ref;
          ref = editor.getCursorPosition(), cursorRow = ref.row, cursorColumn = ref.column;
          return ch.curRange = equationRangeHandler.getEquationRange(cursorRow, cursorColumn);
        },
        updatePopover: function() {
          var ref, rendered, title;
          if (ch.contextPreviewExists) {
            ref = ch.getCurrentFormula(), title = ref[0], rendered = ref[1];
            return popoverHandler.setContent(getFormulaElement(), title, rendered);
          }
        },
        updateCallback: function() {
          var curContext, curTime;
          if (ch.lastChangeTime != null) {
            curTime = Date.now();
            ch.currentDelayedUpdateId = setTimeout(ch.updateCallback, ch.UPDATE_DELAY - (Date.now() - ch.lastChangeTime));
            return ch.lastChangeTime = null;
          } else {
            ch.currentDelayedUpdateId = null;
            if (ch.contextPreviewExists) {
              curContext = LatexParsingContext.getContext(editor.getSession(), editor.getCursorPosition().row);
              if (curContext !== "equation") {
                return ch.destroyContextPreview();
              } else {
                ch.updateRange();
                return ch.updatePopover();
              }
            }
          }
        },
        delayedUpdatePopover: function() {
          var curDocLength;
          curDocLength = editor.getSession().getLength();
          if (curDocLength !== ch.prevDocLength) {
            setTimeout(ch.updatePosition, 0);
            ch.prevDocLength = curDocLength;
          }
          if (ch.currentDelayedUpdateId != null) {
            ch.lastChangeTime = Date.now();
            return;
          }
          return ch.currentDelayedUpdateId = setTimeout(ch.updateCallback, ch.UPDATE_DELAY);
        },
        createContextPreview: function() {
          ch.updateRange();
          ch.contextPreviewExists = true;
          if (katex == null) {
            initKaTeX(ch.initPopover);
          } else {
            ch.initPopover();
          }
          ch.prevDocLength = editor.getSession().getLength();
          editor.on("change", ch.delayedUpdatePopover);
          return editor.getSession().on("changeScrollTop", ch.updatePosition);
        },
        destroyContextPreview: function() {
          ch.curRange = null;
          ch.contextPreviewExists = false;
          editor.off("change", ch.delayedUpdatePopover);
          editor.getSession().off("changeScrollTop", ch.updatePosition);
          return popoverHandler.destroy(getFormulaElement());
        },
        handleCurrentContext: function() {
          return setTimeout((function() {
            var currentContext, cursorColumn, cursorRow, ref;
            if (ch.currentDelayedUpdateId != null) {
              return;
            }
            ref = editor.getCursorPosition(), cursorRow = ref.row, cursorColumn = ref.column;
            currentContext = LatexParsingContext.getContext(editor.getSession(), cursorRow);
            if (ch.contextPreviewExists && currentContext !== "equation") {
              return ch.destroyContextPreview();
            } else if (!ch.contextPreviewExists && currentContext === "equation") {
              return ch.createContextPreview();
            }
          }), 0);
        }
      };
      sh = SelectionHandler = {
        hideSelectionPopover: function() {
          popoverHandler.destroy(getFormulaElement());
          editor.off("changeSelection", sh.hideSelectionPopover);
          editor.getSession().off("changeScrollTop", sh.hideSelectionPopover);
          editor.getSession().off("changeScrollLeft", sh.hideSelectionPopover);
        },
        renderSelectionUnderCursor: function() {
          var content, cursorColumn, cursorPosition, cursorRow, popoverPosition, ref;
          ref = editor.getCursorPosition(), cursorRow = ref.row, cursorColumn = ref.column;
          cursorPosition = editor.renderer.textToScreenCoordinates(cursorRow, cursorColumn);
          popoverPosition = {
            top: (cursorPosition.pageY + 24) + "px",
            left: cursorPosition.pageX + "px"
          };
          content = katex.renderToString(editor.getSelectedText(), KATEX_OPTIONS);
          popoverHandler.show(getFormulaElement(), "Preview", content, popoverPosition);
          editor.on("changeSelection", sh.hideSelectionPopover);
          editor.getSession().on("changeScrollTop", sh.hideSelectionPopover);
          editor.getSession().on("changeScrollLeft", sh.hideSelectionPopover);
        },
        createPopover: function(editor) {
          if (!ch.contextPreviewExists) {
            if (katex == null) {
              initKaTeX(sh.renderSelectionUnderCursor);
              return;
            }
            return sh.renderSelectionUnderCursor();
          }
        }
      };
      editor.commands.addCommand({
        name: "previewLaTeXFormula",
        bindKey: {
          win: "Alt-p",
          mac: "Alt-p"
        },
        exec: SelectionHandler.createPopover
      });
      editor.on("changeSelection", ContextHandler.handleCurrentContext);
    };
  });

}).call(this);
