// Generated by CoffeeScript 1.10.0
(function() {
  var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  define(function(require, exports, module) {
    var ConstrainedTokenIterator, ContextHandler, EquationRangeHandler, LatexParsingContext, Range, TokenIterator, TokenSequenceFinder, equalTokens, findSurroundingBrackets, initKaTeX, katex, myKatexLoader;
    LatexParsingContext = require("ace/ext/papeeria/latex_parsing_context");
    TokenIterator = require("ace/token_iterator").TokenIterator;
    Range = require("ace/range").Range;
    findSurroundingBrackets = require("ace/ext/papeeria/highlighter").findSurroundingBrackets;
    myKatexLoader = null;
    katex = null;
    initKaTeX = function(onLoaded) {
      if (myKatexLoader == null) {
        myKatexLoader = function(consumer) {
          return require(["ace/ext/katex"], function(katexInner) {
            return consumer(katexInner);
          });
        };
      }
      myKatexLoader(function(katexInner) {
        katex = katexInner;
        return onLoaded();
      });
    };
    equalTokens = function(token1, token2) {
      return token1.type === token2.type && token1.value.trim() === token2.value.trim();
    };
    ContextHandler = (function() {
      ContextHandler.UPDATE_DELAY = 1000;

      ContextHandler.KATEX_OPTIONS = {
        displayMode: true,
        throwOnError: false
      };

      ContextHandler.getMacrosArgumentRange = function(session, argumentStartPos) {
        var argumentRange;
        argumentRange = findSurroundingBrackets(session, argumentStartPos);
        if (argumentRange.mismatch) {
          return null;
        } else {
          return new Range(argumentRange.start.row, argumentRange.start.column + 1, argumentRange.end.row, argumentRange.end.column);
        }
      };

      ContextHandler.getWholeEquation = function(session, tokenIterator) {
        var acceptToken, argumentRange, bracketPosition, curLabelParameter, curLabelTokens, curLine, labelParameters, labelSequenceIndex, range, token, tokenPosition, tokenValues;
        tokenValues = [];
        labelSequenceIndex = 0;
        labelParameters = [];
        curLabelParameter = null;
        curLabelTokens = [];
        range = tokenIterator.range;
        token = tokenIterator.getCurrentToken();
        tokenPosition = tokenIterator.getCurrentTokenPosition();
        while (token != null) {
          acceptToken = true;
          if (token.type === "storage.type.equation" && token.value === "\\label") {
            curLine = session.getLine(tokenPosition.row);
            bracketPosition = tokenPosition.column + "\\label".length;
            if (curLine[bracketPosition] === "{") {
              argumentRange = ContextHandler.getMacrosArgumentRange(session, {
                row: tokenPosition.row,
                column: bracketPosition + 1
              });
              if (argumentRange != null) {
                acceptToken = false;
                labelParameters.push(session.getTextRange(argumentRange));
                tokenIterator.stepTo(argumentRange.end.row, argumentRange.end.column + 1);
              }
            }
          }
          if (acceptToken) {
            tokenValues.push(token.value);
          }
          tokenIterator.stepForward();
          token = tokenIterator.getCurrentToken();
          tokenPosition = tokenIterator.getCurrentTokenPosition();
        }
        return {
          params: labelParameters,
          equation: tokenValues.join("")
        };
      };

      function ContextHandler(editor1, jqEditorContainer1, popoverHandler1, equationRangeHandler1, getFormulaElement) {
        this.editor = editor1;
        this.jqEditorContainer = jqEditorContainer1;
        this.popoverHandler = popoverHandler1;
        this.equationRangeHandler = equationRangeHandler1;
        this.getFormulaElement = getFormulaElement;
        this.handleCurrentContext = bind(this.handleCurrentContext, this);
        this.delayedUpdatePopover = bind(this.delayedUpdatePopover, this);
        this.updateCallback = bind(this.updateCallback, this);
        this.updatePosition = bind(this.updatePosition, this);
        this.initPopover = bind(this.initPopover, this);
        this.contextPreviewExists = false;
      }

      ContextHandler.prototype.getPopoverPosition = function(row) {
        return {
          top: (this.editor.renderer.textToScreenCoordinates(row + 2, 1).pageY) + "px",
          left: (this.jqEditorContainer.position().left) + "px"
        };
      };

      ContextHandler.prototype.getCurrentFormula = function() {
        var e, endSequence, endString, equationString, error, labelParameters, ref, ref1, startColumn, startRow, startSequence, startString, title, token, tokenIterator;
        try {
          if (this.curStartId !== this.curEndId) {
            startSequence = EquationRangeHandler.BEGIN_EQUATION_TOKEN_SEQUENCES[this.curStartId].slice(0).reverse();
            startString = ((function() {
              var j, len, results;
              results = [];
              for (j = 0, len = startSequence.length; j < len; j++) {
                token = startSequence[j];
                results.push(token.value);
              }
              return results;
            })()).join("");
            endSequence = EquationRangeHandler.END_EQUATION_TOKEN_SEQUENCES[this.curEndId];
            endString = ((function() {
              var j, len, results;
              results = [];
              for (j = 0, len = endSequence.length; j < len; j++) {
                token = endSequence[j];
                results.push(token.value);
              }
              return results;
            })()).join("");
            return {
              title: "Error!",
              content: "Starting and ending sequences don't match: " + startString + " and " + endString
            };
          }
          ref = this.curInnerRange.start, startRow = ref.row, startColumn = ref.column;
          tokenIterator = new ConstrainedTokenIterator(this.editor.getSession(), this.curInnerRange, startRow, startColumn);
          tokenIterator.stepForward();
          ref1 = ContextHandler.getWholeEquation(this.editor.getSession(), tokenIterator), labelParameters = ref1.params, equationString = ref1.equation;
          title = labelParameters.length === 0 ? "Formula" : labelParameters.join(", ");
          return {
            title: title,
            content: katex.renderToString(equationString, ContextHandler.KATEX_OPTIONS)
          };
        } catch (error) {
          e = error;
          return {
            title: "Error!",
            content: e
          };
        }
      };

      ContextHandler.prototype.initPopover = function() {
        return setTimeout(((function(_this) {
          return function() {
            var popoverPosition, ref, rendered, title;
            popoverPosition = _this.getPopoverPosition(_this.getEquationEndRow());
            ref = _this.getCurrentFormula(), title = ref.title, rendered = ref.content;
            return _this.popoverHandler.show(title, rendered, popoverPosition);
          };
        })(this)), 0);
      };

      ContextHandler.prototype.getEquationEndRow = function() {
        var i;
        i = this.editor.getCursorPosition().row;
        while (LatexParsingContext.getContext(this.editor.getSession(), i) === "equation") {
          i += 1;
        }
        return i;
      };

      ContextHandler.prototype.updatePosition = function() {
        return this.popoverHandler.setPosition(this.getPopoverPosition(this.getEquationEndRow()));
      };

      ContextHandler.prototype.updateRange = function() {
        var cursorColumn, cursorRow, ref, ref1;
        ref = this.editor.getCursorPosition(), cursorRow = ref.row, cursorColumn = ref.column;
        return ref1 = this.equationRangeHandler.getEquationRange(cursorRow, cursorColumn), this.curOuterRange = ref1.outer, this.curInnerRange = ref1.inner, this.curStartId = ref1.start, this.curEndId = ref1.end, ref1;
      };

      ContextHandler.prototype.updatePopover = function() {
        var ref, rendered, title;
        if (this.contextPreviewExists) {
          ref = this.getCurrentFormula(), title = ref.title, rendered = ref.content;
          return this.popoverHandler.setContent(title, rendered);
        }
      };

      ContextHandler.prototype.updateCallback = function() {
        var curContext, curTime, cursorColumn, cursorRow, ref;
        if (this.lastChangeTime != null) {
          curTime = Date.now();
          if (curTime - this.lastChangeTime > ContextHandler.UPDATE_DELAY) {
            return;
          }
          this.currentDelayedUpdateId = setTimeout(this.updateCallback, ContextHandler.UPDATE_DELAY - (curTime - this.lastChangeTime));
          return this.lastChangeTime = null;
        } else {
          this.currentDelayedUpdateId = null;
          if (this.contextPreviewExists) {
            ref = this.editor.getCursorPosition(), cursorRow = ref.row, cursorColumn = ref.column;
            curContext = LatexParsingContext.getContext(this.editor.getSession(), cursorRow, cursorColumn);
            if (curContext !== "equation") {
              return this.destroyContextPreview();
            } else {
              this.updateRange();
              return this.updatePopover();
            }
          }
        }
      };

      ContextHandler.prototype.delayedUpdatePopover = function() {
        var curDocLength;
        curDocLength = this.editor.getSession().getLength();
        if (curDocLength !== this.prevDocLength) {
          setTimeout(this.updatePosition, 0);
          this.prevDocLength = curDocLength;
        }
        if (this.currentDelayedUpdateId != null) {
          this.lastChangeTime = Date.now();
          return;
        }
        return this.currentDelayedUpdateId = setTimeout(this.updateCallback, ContextHandler.UPDATE_DELAY);
      };

      ContextHandler.prototype.createContextPreview = function() {
        this.updateRange();
        this.contextPreviewExists = true;
        if (katex == null) {
          initKaTeX(this.initPopover);
        } else {
          this.initPopover();
        }
        this.prevDocLength = this.editor.getSession().getLength();
        this.editor.on("change", this.delayedUpdatePopover);
        return this.editor.getSession().on("changeScrollTop", this.updatePosition);
      };

      ContextHandler.prototype.destroyContextPreview = function() {
        this.curInnerRange = null;
        this.curOuterRange = null;
        this.contextPreviewExists = false;
        this.editor.off("change", this.delayedUpdatePopover);
        this.editor.getSession().off("changeScrollTop", this.updatePosition);
        return this.popoverHandler.destroy();
      };

      ContextHandler.prototype.handleCurrentContext = function() {
        return setTimeout(((function(_this) {
          return function() {
            var currentContext, cursorColumn, cursorRow, ref;
            if (_this.currentDelayedUpdateId != null) {
              return;
            }
            ref = _this.editor.getCursorPosition(), cursorRow = ref.row, cursorColumn = ref.column;
            currentContext = LatexParsingContext.getContext(_this.editor.getSession(), cursorRow, cursorColumn);
            if (_this.contextPreviewExists && !_this.curOuterRange.contains(cursorRow, cursorColumn)) {
              _this.destroyContextPreview();
            }
            if (!_this.contextPreviewExists && currentContext === "equation") {
              return _this.createContextPreview();
            }
          };
        })(this)), 0);
      };

      return ContextHandler;

    })();
    ConstrainedTokenIterator = (function() {
      function ConstrainedTokenIterator(session1, range1, row, column) {
        var curToken, ref, tokenColumn, tokenRange, tokenRow;
        this.session = session1;
        this.range = range1;
        this.tokenIterator = new TokenIterator(this.session, row, column);
        curToken = this.tokenIterator.getCurrentToken();
        if (curToken == null) {
          this.outOfRange = false;
        }
        ref = this.tokenIterator.getCurrentTokenPosition(), tokenRow = ref.row, tokenColumn = ref.column;
        tokenRange = new Range(tokenRow, tokenColumn, tokenRow, tokenColumn + curToken.value.length);
        this.outOfRange = !this.range.containsRange(tokenRange);
      }

      ConstrainedTokenIterator.prototype.getCurrentToken = function() {
        if (!this.outOfRange) {
          return this.tokenIterator.getCurrentToken();
        } else {
          return null;
        }
      };

      ConstrainedTokenIterator.prototype.getCurrentTokenPosition = function() {
        if (!this.outOfRange) {
          return this.tokenIterator.getCurrentTokenPosition();
        } else {
          return null;
        }
      };

      ConstrainedTokenIterator.prototype.stepBackward = function() {
        var curToken, ref, tokenColumn, tokenRange, tokenRow;
        this.tokenIterator.stepBackward();
        curToken = this.tokenIterator.getCurrentToken();
        if (curToken == null) {
          this.outOfRange = true;
          return null;
        }
        ref = this.tokenIterator.getCurrentTokenPosition(), tokenRow = ref.row, tokenColumn = ref.column;
        tokenRange = new Range(tokenRow, tokenColumn, tokenRow, tokenColumn + curToken.value.length);
        if (this.range.containsRange(tokenRange)) {
          this.outOfRange = false;
          return curToken;
        } else {
          this.outOfRange = true;
          return null;
        }
      };

      ConstrainedTokenIterator.prototype.stepForward = function() {
        var curToken, ref, tokenColumn, tokenRange, tokenRow;
        this.tokenIterator.stepForward();
        curToken = this.tokenIterator.getCurrentToken();
        if (curToken == null) {
          this.outOfRange = true;
          return null;
        }
        ref = this.tokenIterator.getCurrentTokenPosition(), tokenRow = ref.row, tokenColumn = ref.column;
        tokenRange = new Range(tokenRow, tokenColumn, tokenRow, tokenColumn + curToken.value.length);
        if (this.range.containsRange(tokenRange)) {
          this.outOfRange = false;
          return curToken;
        } else {
          this.outOfRange = true;
          return null;
        }
      };

      ConstrainedTokenIterator.prototype.stepTo = function(row, column) {
        this.tokenIterator = new TokenIterator(this.session, row, column);
        return this.outOfRange = !this.range.contains(row, column);
      };

      return ConstrainedTokenIterator;

    })();
    TokenSequenceFinder = (function() {
      function TokenSequenceFinder(tokenSequences) {
        var i, j, ref;
        this.tokenSequences = tokenSequences;
        this.numSequences = this.tokenSequences.length;
        this.currentIndices = Array(this.numSequences);
        for (i = j = 0, ref = this.numSequences; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
          this.currentIndices[i] = 0;
        }
      }

      TokenSequenceFinder.prototype.progressIndices = function(token) {
        var currentIndex, i, j, ref, results, tokenSequence;
        results = [];
        for (i = j = 0, ref = this.numSequences; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
          tokenSequence = this.tokenSequences[i];
          currentIndex = this.currentIndices[i];
          if (equalTokens(token, tokenSequence[currentIndex])) {
            results.push(this.currentIndices[i] += 1);
          } else {
            results.push(this.currentIndices[i] = 0);
          }
        }
        return results;
      };

      TokenSequenceFinder.prototype.getMaybeFinishedSequenceId = function() {
        var i, j, ref;
        for (i = j = 0, ref = this.numSequences; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
          if (this.currentIndices[i] === this.tokenSequences[i].length) {
            return i;
          }
        }
        return null;
      };

      return TokenSequenceFinder;

    })();
    EquationRangeHandler = (function() {
      EquationRangeHandler.BEGIN_EQUATION_TOKEN_SEQUENCES = [
        [
          {
            type: "rparen",
            value: "}"
          }, {
            type: "variable.parameter",
            value: "equation"
          }, {
            type: "lparen",
            value: "{"
          }, {
            type: "storage.type",
            value: "\\begin"
          }
        ], [
          {
            type: "rparen",
            value: "}"
          }, {
            type: "variable.parameter",
            value: "equation*"
          }, {
            type: "lparen",
            value: "{"
          }, {
            type: "storage.type",
            value: "\\begin"
          }
        ], [
          {
            type: "string",
            value: "\\["
          }
        ], [
          {
            type: "string",
            value: "$"
          }
        ], [
          {
            type: "string",
            value: "$$"
          }
        ]
      ];

      EquationRangeHandler.END_EQUATION_TOKEN_SEQUENCES = [
        [
          {
            type: "storage.type",
            value: "\\end"
          }, {
            type: "lparen",
            value: "{"
          }, {
            type: "variable.parameter",
            value: "equation"
          }, {
            type: "rparen",
            value: "}"
          }
        ], [
          {
            type: "storage.type",
            value: "\\end"
          }, {
            type: "lparen",
            value: "{"
          }, {
            type: "variable.parameter",
            value: "equation*"
          }, {
            type: "rparen",
            value: "}"
          }
        ], [
          {
            type: "string",
            value: "\\]"
          }
        ], [
          {
            type: "string",
            value: "$"
          }
        ], [
          {
            type: "string",
            value: "$$"
          }
        ]
      ];

      function EquationRangeHandler(editor1) {
        this.editor = editor1;
      }

      EquationRangeHandler.prototype.getBoundary = function(tokenIterator, start) {
        var boundarySequence, boundarySequences, curToken, curTokenColumn, curTokenLength, curTokenRow, equationInnerBoundary, equationOuterBoundary, finishedSequence, i, j, k, l, len, len1, maybeFinishedSequenceId, moveFromBoundary, moveToBoundary, ref, ref1, ref2, ref3, token, tokenSequenceFinder;
        moveToBoundary = start ? ((function(_this) {
          return function() {
            return tokenIterator.stepBackward();
          };
        })(this)) : ((function(_this) {
          return function() {
            return tokenIterator.stepForward();
          };
        })(this));
        moveFromBoundary = start ? ((function(_this) {
          return function() {
            return tokenIterator.stepForward();
          };
        })(this)) : ((function(_this) {
          return function() {
            return tokenIterator.stepBackward();
          };
        })(this));
        boundarySequences = (start ? EquationRangeHandler.BEGIN_EQUATION_TOKEN_SEQUENCES : EquationRangeHandler.END_EQUATION_TOKEN_SEQUENCES);
        if (tokenIterator.getCurrentToken() == null) {
          moveFromBoundary();
          if (tokenIterator.getCurrentToken() == null) {
            return null;
          }
        } else {
          for (j = 0, len = boundarySequences.length; j < len; j++) {
            boundarySequence = boundarySequences[j];
            ref = boundarySequence.slice(0).reverse();
            for (k = 0, len1 = ref.length; k < len1; k++) {
              token = ref[k];
              curToken = tokenIterator.getCurrentToken();
              if ((curToken != null) && equalTokens(token, curToken)) {
                moveFromBoundary();
              }
            }
          }
        }
        tokenSequenceFinder = new TokenSequenceFinder(boundarySequences);
        while (true) {
          moveToBoundary();
          curToken = tokenIterator.getCurrentToken();
          if (curToken == null) {
            return null;
          }
          tokenSequenceFinder.progressIndices(curToken);
          maybeFinishedSequenceId = tokenSequenceFinder.getMaybeFinishedSequenceId();
          if (maybeFinishedSequenceId != null) {
            ref1 = tokenIterator.getCurrentTokenPosition(), curTokenRow = ref1.row, curTokenColumn = ref1.column;
            curTokenLength = curToken.value.length;
            finishedSequence = boundarySequences[maybeFinishedSequenceId];
            equationOuterBoundary = {
              row: curTokenRow,
              column: curTokenColumn + (start ? 0 : curTokenLength)
            };
            for (i = l = 0, ref2 = finishedSequence.length - 1; 0 <= ref2 ? l < ref2 : l > ref2; i = 0 <= ref2 ? ++l : --l) {
              moveFromBoundary();
            }
            ref3 = tokenIterator.getCurrentTokenPosition(), curTokenRow = ref3.row, curTokenColumn = ref3.column;
            curTokenLength = tokenIterator.getCurrentToken().value.length;
            equationInnerBoundary = {
              row: curTokenRow,
              column: curTokenColumn + (start ? curTokenLength : 0)
            };
            moveFromBoundary();
            return {
              id: maybeFinishedSequenceId,
              outer: equationOuterBoundary,
              inner: equationInnerBoundary
            };
          }
        }
      };

      EquationRangeHandler.prototype.getEquationRange = function(row, column) {
        var end, endId, innerEnd, innerRange, innerStart, outerEnd, outerRange, outerStart, start, startId, tokenIterator;
        tokenIterator = new TokenIterator(this.editor.getSession(), row, column);
        end = this.getBoundary(tokenIterator, false);
        start = this.getBoundary(tokenIterator, true);
        if (!((start != null) && (end != null))) {
          return {
            outer: null,
            inner: null,
            start: null,
            end: null
          };
        }
        endId = end.id, outerEnd = end.outer, innerEnd = end.inner;
        startId = start.id, outerStart = start.outer, innerStart = start.inner;
        outerRange = new Range(outerStart.row, outerStart.column, outerEnd.row, outerEnd.column);
        innerRange = new Range(innerStart.row, innerStart.column, innerEnd.row, innerEnd.column);
        return {
          outer: outerRange,
          inner: innerRange,
          start: startId,
          end: endId
        };
      };

      return EquationRangeHandler;

    })();
    exports.ContextHandler = ContextHandler;
    exports.ConstrainedTokenIterator = ConstrainedTokenIterator;
    exports.EquationRangeHandler = EquationRangeHandler;
    exports.setupPreviewer = function(editor, popoverHandler, katexLoader) {
      var KATEX_OPTIONS, SelectionHandler, contextHandler, cssDemoPath, equationRangeHandler, jqEditorContainer, jqPopoverContainer, linkDemo, sh, span;
      myKatexLoader = katexLoader;
      if (popoverHandler == null) {
        cssDemoPath = require.toUrl("./katex-demo.css");
        linkDemo = $("<link>").attr({
          rel: "stylesheet",
          href: cssDemoPath
        });
        $("head").append(linkDemo);
        span = $("<span>").attr({
          id: "formula"
        });
        $("body").append(span);
        jqPopoverContainer = $("#formula");
        popoverHandler = {
          options: {
            html: true,
            placement: "bottom",
            trigger: "manual",
            container: editor.container
          },
          show: function(title, content, position) {
            jqPopoverContainer.css(position);
            popoverHandler.options.content = content;
            popoverHandler.options.title = title;
            jqPopoverContainer.popover(popoverHandler.options);
            jqPopoverContainer.popover("show");
          },
          destroy: function() {
            return jqPopoverContainer.popover("destroy");
          },
          popoverExists: function() {
            var ref;
            return ((ref = jqPopoverContainer.data()) != null ? ref.popover : void 0) != null;
          },
          setContent: function(title, content) {
            var popoverElement;
            popoverElement = jqPopoverContainer.data().popover.tip();
            popoverElement.children(".popover-content").html(content);
            return popoverElement.children(".popover-title").text(title);
          },
          setPosition: function(position) {
            return jqPopoverContainer.data().popover.tip().css(position);
          }
        };
      }
      jqEditorContainer = $(editor.container);
      KATEX_OPTIONS = {
        displayMode: true,
        throwOnError: false
      };
      equationRangeHandler = new EquationRangeHandler(editor);
      contextHandler = new ContextHandler(editor, jqEditorContainer, popoverHandler, equationRangeHandler);
      sh = SelectionHandler = {
        hideSelectionPopover: function() {
          popoverHandler.destroy();
          editor.off("changeSelection", sh.hideSelectionPopover);
          editor.getSession().off("changeScrollTop", sh.hideSelectionPopover);
          editor.getSession().off("changeScrollLeft", sh.hideSelectionPopover);
        },
        renderSelectionUnderCursor: function() {
          var content, cursorColumn, cursorPosition, cursorRow, popoverPosition, ref;
          ref = editor.getCursorPosition(), cursorRow = ref.row, cursorColumn = ref.column;
          cursorPosition = editor.renderer.textToScreenCoordinates(cursorRow, cursorColumn);
          popoverPosition = {
            top: (cursorPosition.pageY + 24) + "px",
            left: cursorPosition.pageX + "px"
          };
          content = katex.renderToString(editor.getSelectedText(), KATEX_OPTIONS);
          popoverHandler.show("Preview", content, popoverPosition);
          editor.on("changeSelection", sh.hideSelectionPopover);
          editor.getSession().on("changeScrollTop", sh.hideSelectionPopover);
          editor.getSession().on("changeScrollLeft", sh.hideSelectionPopover);
        },
        createPopover: function(editor) {
          if (!ch.contextPreviewExists) {
            if (katex == null) {
              initKaTeX(sh.renderSelectionUnderCursor);
              return;
            }
            return sh.renderSelectionUnderCursor();
          }
        }
      };
      editor.commands.addCommand({
        name: "previewLaTeXFormula",
        bindKey: {
          win: "Alt-p",
          mac: "Alt-p"
        },
        exec: SelectionHandler.createPopover
      });
      editor.on("changeSelection", contextHandler.handleCurrentContext);
    };
  });

}).call(this);
