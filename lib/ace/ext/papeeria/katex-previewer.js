// Generated by CoffeeScript 1.12.6
(function() {
  var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  define(function(require, exports, module) {
    var ConstrainedTokenIterator, ContextHandler, EquationRangeHandler, LatexParsingContext, Range, SelectionHandler, TokenIterator, equalTokens, findSurroundingBrackets, initKaTeX, katex, myContextHandler, myKatexLoader, reset, setupPreviewer, sh;
    LatexParsingContext = require("ace/ext/papeeria/latex_parsing_context");
    TokenIterator = require("ace/token_iterator").TokenIterator;
    Range = require("ace/range").Range;
    findSurroundingBrackets = require("ace/ext/papeeria/highlighter").findSurroundingBrackets;
    myKatexLoader = null;
    katex = null;
    initKaTeX = function(onLoaded) {
      if (myKatexLoader == null) {
        myKatexLoader = function(consumer) {
          return require(["ace/ext/katex"], function(katexInner) {
            return consumer(katexInner);
          });
        };
      }
      return myKatexLoader(function(katexInner) {
        katex = katexInner;
        return onLoaded();
      });
    };
    equalTokens = function(token1, token2) {
      return token1.type === token2.type && token1.value.trim() === token2.value.trim();
    };
    ContextHandler = (function() {
      ContextHandler.UPDATE_DELAY = 1000;

      ContextHandler.KATEX_OPTIONS = {
        displayMode: true,
        throwOnError: false
      };

      ContextHandler.extractEquation = function(session, range) {
        var bracketString, closingBracketIndex, closingBracketPos, content, curIndex, end, endIndex, equationStrings, joinedLines, labelRe, labelStartIndex, labels, matchedString, openingBracketIndex, openingBracketPos, result, row, start, startIndex;
        start = range.start, end = range.end;
        joinedLines = ((function() {
          var j, ref, ref1, results;
          results = [];
          for (row = j = ref = start.row, ref1 = end.row; ref <= ref1 ? j <= ref1 : j >= ref1; row = ref <= ref1 ? ++j : --j) {
            results.push(session.getLine(row));
          }
          return results;
        })()).join("\n");
        startIndex = session.doc.positionToIndex(start, start.row);
        endIndex = session.doc.positionToIndex(end, start.row) + 1;
        content = joinedLines.substring(startIndex, endIndex - 1);
        labelRe = /\\label\s*\{/g;
        bracketString = "{";
        labels = [];
        equationStrings = [];
        curIndex = 0;
        while (true) {
          result = labelRe.exec(content);
          if (result === null) {
            equationStrings.push(content.substring(curIndex));
            break;
          }
          labelStartIndex = result.index;
          equationStrings.push(content.substring(curIndex, labelStartIndex));
          matchedString = result[0];
          openingBracketIndex = labelStartIndex + matchedString.length - 1;
          openingBracketPos = session.doc.indexToPosition(startIndex + openingBracketIndex + 1, start.row);
          closingBracketPos = session.findMatchingBracket(openingBracketPos, bracketString);
          if (closingBracketPos === null) {
            equationStrings.push(matchedString);
            curIndex = openingBracketIndex + 1;
          } else {
            closingBracketIndex = session.doc.positionToIndex(closingBracketPos, start.row) - startIndex;
            labels.push(content.substring(openingBracketIndex + 1, closingBracketIndex));
            curIndex = closingBracketIndex + 1;
          }
        }
        return {
          labels: labels,
          equation: equationStrings.join(" ")
        };
      };

      function ContextHandler(editor1, popoverHandler1, equationRangeHandler1, I18N1) {
        this.editor = editor1;
        this.popoverHandler = popoverHandler1;
        this.equationRangeHandler = equationRangeHandler1;
        this.I18N = I18N1;
        this.handleCurrentContext = bind(this.handleCurrentContext, this);
        this.delayedUpdatePopover = bind(this.delayedUpdatePopover, this);
        this.updateCallback = bind(this.updateCallback, this);
        this.updatePosition = bind(this.updatePosition, this);
        this.initPopover = bind(this.initPopover, this);
        this.jqEditorContainer = $(this.editor.container);
        this.contextPreviewExists = false;
        this.rangeCorrect = false;
        this.currentRange = null;
      }

      ContextHandler.prototype.getPopoverPosition = function(row) {
        return {
          top: (this.editor.renderer.textToScreenCoordinates(row + 2, 1).pageY) + "px",
          left: (this.jqEditorContainer.position().left) + "px"
        };
      };

      ContextHandler.prototype.getCurrentFormula = function() {
        var e, equation, labels, ref, title;
        try {
          if (this.currentRange == null) {
            throw "Inconsistent state";
          }
          if (!this.rangeCorrect) {
            throw "<div style=\"text-align:center\"><p>" + (this.messages.join("\n")) + "</p></div>";
          }
          ref = ContextHandler.extractEquation(this.editor.getSession(), this.currentRange), labels = ref.labels, equation = ref.equation;
          title = labels.length === 0 ? "Formula" : labels.join(", ");
          return {
            title: title,
            content: katex.renderToString(equation, ContextHandler.KATEX_OPTIONS)
          };
        } catch (error) {
          e = error;
          return {
            title: "Error!",
            content: e
          };
        }
      };

      ContextHandler.prototype.initPopover = function() {
        var popoverPosition, ref, rendered, title;
        popoverPosition = this.getPopoverPosition(this.getEquationEndRow());
        ref = this.getCurrentFormula(), title = ref.title, rendered = ref.content;
        return this.popoverHandler.show(title, rendered, popoverPosition);
      };

      ContextHandler.prototype.getEquationEndRow = function() {
        var i;
        i = this.editor.getCursorPosition().row;
        while (LatexParsingContext.getContext(this.editor.getSession(), i) === "equation") {
          i += 1;
        }
        return i;
      };

      ContextHandler.prototype.updatePosition = function() {
        return this.popoverHandler.setPosition(this.getPopoverPosition(this.getEquationEndRow()));
      };

      ContextHandler.prototype.updateRange = function() {
        var cursorPos, reason, reasons, ref;
        cursorPos = this.editor.getCursorPosition();
        ref = this.equationRangeHandler.getEquationRange(cursorPos.row, cursorPos.column), this.rangeCorrect = ref.correct, reasons = ref.reasons, this.currentRange = ref.range;
        return this.messages = (function() {
          var j, len, results;
          results = [];
          for (j = 0, len = reasons.length; j < len; j++) {
            reason = reasons[j];
            results.push(this.I18N.text(reason));
          }
          return results;
        }).call(this);
      };

      ContextHandler.prototype.destroyRange = function() {
        this.currentRange = null;
        return this.rangeCorrect = false;
      };

      ContextHandler.prototype.updatePopover = function() {
        var ref, rendered, title;
        if (this.contextPreviewExists) {
          ref = this.getCurrentFormula(), title = ref.title, rendered = ref.content;
          return this.popoverHandler.setContent(title, rendered);
        }
      };

      ContextHandler.prototype.updateCallback = function() {
        var curContext, curTime, cursorPos;
        if (this.lastChangeTime != null) {
          curTime = Date.now();
          if (curTime - this.lastChangeTime > ContextHandler.UPDATE_DELAY) {
            return;
          }
          this.currentDelayedUpdateId = setTimeout(this.updateCallback, ContextHandler.UPDATE_DELAY - (curTime - this.lastChangeTime));
          return this.lastChangeTime = null;
        } else {
          this.currentDelayedUpdateId = null;
          cursorPos = this.editor.getCursorPosition();
          curContext = LatexParsingContext.getContext(this.editor.getSession(), cursorPos.row, cursorPos.column);
          if (curContext === "equation") {
            this.updateRange();
          } else {
            this.destroyRange();
            this.disableUpdates();
          }
          if (this.currentRange != null) {
            if (this.contextPreviewExists) {
              return this.updatePopover();
            } else {
              return this.createContextPreview();
            }
          } else {
            return this.destroyContextPreview();
          }
        }
      };

      ContextHandler.prototype.delayedUpdatePopover = function() {
        var curDocLength;
        curDocLength = this.editor.getSession().getLength();
        if (this.contextPreviewExists && curDocLength !== this.prevDocLength) {
          setTimeout(this.updatePosition, 0);
          this.prevDocLength = curDocLength;
        }
        if (this.currentDelayedUpdateId != null) {
          this.lastChangeTime = Date.now();
          return;
        }
        return this.currentDelayedUpdateId = setTimeout(this.updateCallback, ContextHandler.UPDATE_DELAY);
      };

      ContextHandler.prototype.createContextPreview = function() {
        this.contextPreviewExists = true;
        if (katex == null) {
          return initKaTeX(this.initPopover);
        } else {
          return this.initPopover();
        }
      };

      ContextHandler.prototype.enableUpdates = function() {
        this.prevDocLength = this.editor.getSession().getLength();
        this.editor.on("change", this.delayedUpdatePopover);
        return this.editor.getSession().on("changeScrollTop", this.updatePosition);
      };

      ContextHandler.prototype.disableUpdates = function() {
        this.currentDelayedUpdateId = null;
        this.editor.off("change", this.delayedUpdatePopover);
        return this.editor.getSession().off("changeScrollTop", this.updatePosition);
      };

      ContextHandler.prototype.destroyContextPreview = function() {
        this.contextPreviewExists = false;
        return this.popoverHandler.destroy();
      };

      ContextHandler.prototype.destroyEverything = function() {
        this.destroyRange();
        this.disableUpdates();
        return this.destroyContextPreview();
      };

      ContextHandler.prototype.handleCurrentContext = function() {
        return setTimeout(((function(_this) {
          return function() {
            var currentContext, cursorPos;
            if (_this.currentDelayedUpdateId != null) {
              return;
            }
            cursorPos = _this.editor.getCursorPosition();
            currentContext = LatexParsingContext.getContext(_this.editor.getSession(), cursorPos.row, cursorPos.column);
            if ((_this.currentRange != null) && !_this.currentRange.contains(cursorPos.row, cursorPos.column)) {
              _this.destroyRange();
              _this.disableUpdates();
            }
            if ((_this.currentRange == null) && _this.contextPreviewExists) {
              _this.destroyContextPreview();
            }
            if ((_this.currentRange == null) && currentContext === "equation") {
              _this.updateRange();
              _this.enableUpdates();
            }
            if ((_this.currentRange != null) && !_this.contextPreviewExists) {
              return _this.createContextPreview();
            }
          };
        })(this)), 0);
      };

      return ContextHandler;

    })();
    ConstrainedTokenIterator = (function() {
      function ConstrainedTokenIterator(session1, range1, row, column) {
        var curToken, ref, tokenColumn, tokenRange, tokenRow;
        this.session = session1;
        this.range = range1;
        this.tokenIterator = new TokenIterator(this.session, row, column);
        curToken = this.tokenIterator.getCurrentToken();
        if (curToken == null) {
          this.outOfRange = false;
        }
        ref = this.tokenIterator.getCurrentTokenPosition(), tokenRow = ref.row, tokenColumn = ref.column;
        tokenRange = new Range(tokenRow, tokenColumn, tokenRow, tokenColumn + curToken.value.length);
        this.outOfRange = !this.range.containsRange(tokenRange);
      }

      ConstrainedTokenIterator.prototype.getCurrentToken = function() {
        if (!this.outOfRange) {
          return this.tokenIterator.getCurrentToken();
        } else {
          return null;
        }
      };

      ConstrainedTokenIterator.prototype.getCurrentTokenPosition = function() {
        if (!this.outOfRange) {
          return this.tokenIterator.getCurrentTokenPosition();
        } else {
          return null;
        }
      };

      ConstrainedTokenIterator.prototype.stepBackward = function() {
        var curToken, ref, tokenColumn, tokenRange, tokenRow;
        this.tokenIterator.stepBackward();
        curToken = this.tokenIterator.getCurrentToken();
        if (curToken == null) {
          this.outOfRange = true;
          return null;
        }
        ref = this.tokenIterator.getCurrentTokenPosition(), tokenRow = ref.row, tokenColumn = ref.column;
        tokenRange = new Range(tokenRow, tokenColumn, tokenRow, tokenColumn + curToken.value.length);
        if (this.range.containsRange(tokenRange)) {
          this.outOfRange = false;
          return curToken;
        } else {
          this.outOfRange = true;
          return null;
        }
      };

      ConstrainedTokenIterator.prototype.stepForward = function() {
        var curToken, ref, tokenColumn, tokenRange, tokenRow;
        this.tokenIterator.stepForward();
        curToken = this.tokenIterator.getCurrentToken();
        if (curToken == null) {
          this.outOfRange = true;
          return null;
        }
        ref = this.tokenIterator.getCurrentTokenPosition(), tokenRow = ref.row, tokenColumn = ref.column;
        tokenRange = new Range(tokenRow, tokenColumn, tokenRow, tokenColumn + curToken.value.length);
        if (this.range.containsRange(tokenRange)) {
          this.outOfRange = false;
          return curToken;
        } else {
          this.outOfRange = true;
          return null;
        }
      };

      ConstrainedTokenIterator.prototype.stepTo = function(row, column) {
        this.tokenIterator = new TokenIterator(this.session, row, column);
        return this.outOfRange = !this.range.contains(row, column);
      };

      return ConstrainedTokenIterator;

    })();
    EquationRangeHandler = (function() {
      EquationRangeHandler.DOCUMENT_END_ERROR_CODE = "js.math_preview.error.document_end";

      EquationRangeHandler.EMPTY_LINE_ERROR_CODE = "js.math_preview.error.empty_line";

      EquationRangeHandler.WHITESPACE_LINE_ERROR_CODE = "js.math_preview.error.whitespace_line";

      function EquationRangeHandler(editor1) {
        this.editor = editor1;
      }

      EquationRangeHandler.prototype.getBoundary = function(session, row, column, start) {
        var correct, curColumn, curIndex, curRow, nextColumn, nextIndex, nextRow, reason, ref, ref1, summand, token;
        summand = start ? -1 : 1;
        curIndex = session.doc.positionToIndex({
          row: row,
          column: column
        });
        ref = session.doc.indexToPosition(curIndex), curRow = ref.row, curColumn = ref.column;
        while (true) {
          nextIndex = curIndex + summand;
          ref1 = session.doc.indexToPosition(nextIndex), nextRow = ref1.row, nextColumn = ref1.column;
          if (nextColumn === curColumn && nextRow === curRow) {
            return {
              correct: false,
              reason: EquationRangeHandler.DOCUMENT_END_ERROR_CODE,
              row: curRow,
              column: curColumn
            };
          }
          if (LatexParsingContext.getContext(session, nextRow, nextColumn) !== "equation") {
            correct = true;
            reason = null;
            token = session.getTokenAt(curRow, curColumn);
            if (token == null) {
              correct = false;
              reason = EquationRangeHandler.EMPTY_LINE_ERROR_CODE;
            } else if (LatexParsingContext.isType(token, "error")) {
              correct = false;
              reason = EquationRangeHandler.WHITESPACE_LINE_ERROR_CODE;
            }
            return {
              correct: correct,
              reason: reason,
              row: curRow,
              column: curColumn
            };
          }
          curIndex = nextIndex;
          curRow = nextRow;
          curColumn = nextColumn;
        }
      };

      EquationRangeHandler.prototype.getEquationRange = function(row, column) {
        var end, reasons, start;
        start = this.getBoundary(this.editor.getSession(), row, column, true);
        end = this.getBoundary(this.editor.getSession(), row, column, false);
        reasons = [];
        if (!start.correct) {
          reasons.push(start.reason);
        }
        if (!end.correct) {
          reasons.push(end.reason);
        }
        return {
          correct: start.correct && end.correct,
          reasons: reasons,
          range: new Range(start.row, start.column, end.row, end.column)
        };
      };

      return EquationRangeHandler;

    })();
    myContextHandler = null;
    reset = function() {
      if (myContextHandler != null ? myContextHandler.contextPreviewExists : void 0) {
        return myContextHandler.destroyEverything();
      }
    };
    sh = SelectionHandler = {
      hideSelectionPopover: function() {
        popoverHandler.destroy();
        editor.off("changeSelection", sh.hideSelectionPopover);
        editor.getSession().off("changeScrollTop", sh.hideSelectionPopover);
        return editor.getSession().off("changeScrollLeft", sh.hideSelectionPopover);
      },
      renderSelectionUnderCursor: function() {
        var content, cursorPos, cursorPosition, popoverPosition;
        cursorPos = editor.getCursorPosition();
        cursorPosition = editor.renderer.textToScreenCoordinates(cursorPos.row, cursorPos.column);
        popoverPosition = {
          top: (cursorPosition.pageY + 24) + "px",
          left: cursorPosition.pageX + "px"
        };
        content = katex.renderToString(editor.getSelectedText(), KATEX_OPTIONS);
        popoverHandler.show("Preview", content, popoverPosition);
        editor.on("changeSelection", sh.hideSelectionPopover);
        editor.getSession().on("changeScrollTop", sh.hideSelectionPopover);
        return editor.getSession().on("changeScrollLeft", sh.hideSelectionPopover);
      },
      createPopover: function(editor) {
        if (!(myContextHandler != null ? myContextHandler.contextPreviewExists : void 0)) {
          if (katex == null) {
            initKaTeX(sh.renderSelectionUnderCursor);
            return;
          }
          return sh.renderSelectionUnderCursor();
        }
      }
    };
    setupPreviewer = function(editor, popoverHandler, katexLoader, I18N) {
      var equationRangeHandler;
      myKatexLoader = katexLoader;
      equationRangeHandler = new EquationRangeHandler(editor);
      myContextHandler = new ContextHandler(editor, popoverHandler, equationRangeHandler, I18N);
      return editor.on("changeSelection", myContextHandler.handleCurrentContext);
    };
    exports.testExport = {
      ContextHandler: ContextHandler,
      ConstrainedTokenIterator: ConstrainedTokenIterator,
      EquationRangeHandler: EquationRangeHandler
    };
    exports.reset = reset;
    exports.SelectionHandler = SelectionHandler;
    exports.setupPreviewer = setupPreviewer;
  });

}).call(this);

//# sourceMappingURL=katex-previewer.js.map
