// Generated by CoffeeScript 1.12.6
(function() {
  var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  define(function(require, exports, module) {
    var DictionaryCache, NULL_HASH, Range, Spellchecker, makeSet, mySpellchecker;
    Range = require('ace/range').Range;
    makeSet = function(array) {
      var i, len, set, v;
      set = {};
      for (i = 0, len = array.length; i < len; i++) {
        v = array[i];
        set[v] = true;
      }
      return set;
    };
    NULL_HASH = "";
    Spellchecker = (function() {
      function Spellchecker(editor1) {
        this.editor = editor1;
        this.hasTypoMarker = bind(this.hasTypoMarker, this);
        this.getTypoRange = bind(this.getTypoRange, this);
        this.isWordTypo = bind(this.isWordTypo, this);
        this.getCorrections = bind(this.getCorrections, this);
        this._sendTyposToAce = bind(this._sendTyposToAce, this);
        this.addWordToDictionaryCache = bind(this.addWordToDictionaryCache, this);
        this.isEnabled = bind(this.isEnabled, this);
        this.onHashUpdated = bind(this.onHashUpdated, this);
        this.onSettingsUpdated = bind(this.onSettingsUpdated, this);
        this._fetchTypos = bind(this._fetchTypos, this);
        this.typosHash = NULL_HASH;
        this.language = null;
        this.asyncFetchTypos = function() {};
        this.asyncFetchSuggestions = function() {};
        this.typos = {};
        this.dictionaryCache = new DictionaryCache();
      }

      Spellchecker.prototype._fetchTypos = function(hash) {
        return this.asyncFetchTypos(this.language, (function(_this) {
          return function(typosArray) {
            _this.typos = makeSet(typosArray);
            _this.dictionaryCache.apply(_this.typos);
            _this._sendTyposToAce();
            return _this.typosHash = hash;
          };
        })(this));
      };

      Spellchecker.prototype.onSettingsUpdated = function(settings, asyncFetchTypos, asyncFetchSuggestions) {
        if (this.language !== settings.tag) {
          this.dictionaryCache.clear();
        }
        this.language = settings.tag;
        this.enabled = settings.isEnabled;
        this.splitRe = new RegExp('([^' + settings.punctuation + ']+)', 'g');
        this.matchRe = new RegExp('^[^' + settings.punctuation + ']+$');
        this.asyncFetchTypos = asyncFetchTypos;
        this.asyncFetchSuggestions = asyncFetchSuggestions;
        this.editor.getSession()._emit("changeSpellingCheckSettings", settings);
        return this._fetchTypos(NULL_HASH);
      };

      Spellchecker.prototype.onHashUpdated = function(typosHash) {
        if (this.typosHash !== typosHash) {
          return this._fetchTypos(typosHash);
        }
      };

      Spellchecker.prototype.isEnabled = function() {
        return this.enabled;
      };

      Spellchecker.prototype.addWordToDictionaryCache = function(word, toBlacklist) {
        this.dictionaryCache.addWord(word, toBlacklist);
        this.dictionaryCache.apply(this.typos);
        return this._sendTyposToAce();
      };

      Spellchecker.prototype._sendTyposToAce = function() {
        return this.editor.getSession()._emit("updateSpellcheckingTypos", {
          typos: this.typos
        });
      };

      Spellchecker.prototype.getCorrections = function(token, callback) {
        return this.asyncFetchSuggestions(token, this.language, callback);
      };

      Spellchecker.prototype.isWordTypo = function(word) {
        return !!this.typos[word];
      };

      Spellchecker.prototype.getTypoRange = function(row, column) {
        var i, len, matches, pos, session, w;
        session = this.editor.getSession();
        matches = session.getLine(row).split(this.splitRe);
        pos = 0;
        for (i = 0, len = matches.length; i < len; i++) {
          w = matches[i];
          pos += w.length;
          if ((pos > column) || (pos === column && w.match(this.matchRe))) {
            return new Range(row, pos - w.length, row, pos);
          }
        }
        return session.getWordRange(row, column);
      };

      Spellchecker.prototype.hasTypoMarker = function(range) {
        var k, ref, session, w;
        session = this.editor.getSession();
        if (!this.isWordTypo(session.getTextRange(range))) {
          return false;
        }
        ref = session.getMarkers(true);
        for (k in ref) {
          w = ref[k];
          if (w.type === "typo" && w.range.isEqual(range)) {
            return true;
          }
        }
        return false;
      };

      return Spellchecker;

    })();
    DictionaryCache = (function() {
      function DictionaryCache() {
        this.clear = bind(this.clear, this);
        this.apply = bind(this.apply, this);
        this.addWord = bind(this.addWord, this);
        this.storage = {};
      }

      DictionaryCache.prototype.addWord = function(word, toBlacklist) {
        return this.storage[word] = toBlacklist;
      };

      DictionaryCache.prototype.apply = function(typos) {
        var ref, results, v, w;
        ref = this.storage;
        results = [];
        for (w in ref) {
          v = ref[w];
          if (v) {
            results.push(typos[w] = true);
          } else {
            results.push(delete typos[w]);
          }
        }
        return results;
      };

      DictionaryCache.prototype.clear = function() {
        return this.storage = {};
      };

      return DictionaryCache;

    })();
    mySpellchecker = null;
    return {
      getInstance: function() {
        if (mySpellchecker != null) {
          return mySpellchecker;
        } else {
          throw new Error("Spellchecker has not been initialized");
        }
      },
      setup: function(editor) {
        if (mySpellchecker != null) {
          throw new Error("Spellchecker has already been initialized");
        } else {
          return mySpellchecker = new Spellchecker(editor);
        }
      }
    };
  });

}).call(this);
