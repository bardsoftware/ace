// Generated by CoffeeScript 1.12.6
(function() {
  var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  define(function() {
    var DictionaryCache, NULL_HASH, Spellchecker, makeSet, mySpellchecker;
    makeSet = function(array) {
      var i, len, set, v;
      set = {};
      for (i = 0, len = array.length; i < len; i++) {
        v = array[i];
        set[v] = true;
      }
      return set;
    };
    NULL_HASH = "";
    Spellchecker = (function() {
      function Spellchecker(editor1) {
        this.editor = editor1;
        this.isWordTypo = bind(this.isWordTypo, this);
        this.getCorrections = bind(this.getCorrections, this);
        this._sendTyposToAce = bind(this._sendTyposToAce, this);
        this.addWordToDictionaryCache = bind(this.addWordToDictionaryCache, this);
        this.onHashUpdated = bind(this.onHashUpdated, this);
        this.onSettingsUpdated = bind(this.onSettingsUpdated, this);
        this._fetchTypos = bind(this._fetchTypos, this);
        this.typosHash = NULL_HASH;
        this.language = null;
        this.asyncFetchTypos = function() {};
        this.asyncFetchSuggestions = function() {};
        this.typos = {};
        this.dictionaryCache = new DictionaryCache();
      }

      Spellchecker.prototype._fetchTypos = function(hash) {
        return this.asyncFetchTypos(this.language, (function(_this) {
          return function(typosArray) {
            _this.typos = makeSet(typosArray);
            _this.dictionaryCache.apply(_this.typos);
            _this._sendTyposToAce();
            return _this.typosHash = hash;
          };
        })(this));
      };

      Spellchecker.prototype.onSettingsUpdated = function(settings, asyncFetchTypos, asyncFetchSuggestions) {
        if (this.language !== settings.tag) {
          this.dictionaryCache.clear();
        }
        this.language = settings.tag;
        this.asyncFetchTypos = asyncFetchTypos;
        this.asyncFetchSuggestions = asyncFetchSuggestions;
        this.editor.getSession()._emit("changeSpellingCheckSettings", settings);
        return this._fetchTypos(NULL_HASH);
      };

      Spellchecker.prototype.onHashUpdated = function(typosHash) {
        if (this.typosHash !== typosHash) {
          return this._fetchTypos(typosHash);
        }
      };

      Spellchecker.prototype.addWordToDictionaryCache = function(word, blacklistNotWhitelist) {
        this.dictionaryCache.addWord(word, blacklistNotWhitelist);
        this.dictionaryCache.apply(this.typos);
        return this._sendTyposToAce();
      };

      Spellchecker.prototype._sendTyposToAce = function() {
        return this.editor.getSession()._emit("updateSpellcheckingTypos", {
          typos: this.typos
        });
      };

      Spellchecker.prototype.getCorrections = function(token, callback) {
        return this.asyncFetchSuggestions(token, this.language, callback);
      };

      Spellchecker.prototype.isWordTypo = function(word) {
        return !!this.typos[word];
      };

      return Spellchecker;

    })();
    DictionaryCache = (function() {
      function DictionaryCache() {
        this.clear = bind(this.clear, this);
        this.apply = bind(this.apply, this);
        this.addWord = bind(this.addWord, this);
        this.storage = {};
      }

      DictionaryCache.prototype.addWord = function(word, blacklistNotWhitelist) {
        return this.storage[word] = blacklistNotWhitelist;
      };

      DictionaryCache.prototype.apply = function(typos) {
        var ref, results, v, w;
        ref = this.storage;
        results = [];
        for (w in ref) {
          v = ref[w];
          if (v) {
            results.push(typos[w] = true);
          } else {
            results.push(delete typos[w]);
          }
        }
        return results;
      };

      DictionaryCache.prototype.clear = function() {
        return this.storage = {};
      };

      return DictionaryCache;

    })();
    mySpellchecker = null;
    return {
      getInstance: function() {
        if (mySpellchecker != null) {
          return mySpellchecker;
        } else {
          throw new Error("Spellchecker has not been initialized");
        }
      },
      setup: function(editor) {
        if (mySpellchecker != null) {
          throw new Error("Spellchecker has already been initialized");
        } else {
          return mySpellchecker = new Spellchecker(editor);
        }
      }
    };
  });

}).call(this);
