// Generated by CoffeeScript 1.10.0
(function() {
  define(function(require, exports, module) {
    var TextUtils;
    TextUtils = (function() {
      function TextUtils() {}


      /*
      @param {!int} index - zero-based cursor index
      @param {!string} - text where cursor located
      @returns {!CursorPosition} object with cursor's row and column. If index is out of text's bounds it returns the closest position
      @public
       */

      TextUtils.idxToPosition = function(index, text) {
        var lineIdx, lineStartOffset, newLineMatch, newLineRx, prevLineStartOffset;
        if (index <= 0) {
          return {
            row: 0,
            column: 0
          };
        }
        lineIdx = 0;
        prevLineStartOffset = 0;
        newLineRx = /(\n\r?)/gm;
        newLineMatch = newLineRx.exec(text);
        while (newLineMatch !== null) {
          lineStartOffset = newLineMatch.index + newLineMatch[1].length;
          if (lineStartOffset > index) {
            return {
              row: lineIdx,
              column: index - prevLineStartOffset
            };
          }
          lineIdx++;
          prevLineStartOffset = lineStartOffset;
          newLineMatch = newLineRx.exec(text);
        }
        if (index <= text.length) {
          return {
            row: lineIdx,
            column: index - prevLineStartOffset
          };
        } else {
          return {
            row: lineIdx,
            column: Math.max(text.length - prevLineStartOffset, 0)
          };
        }
      };


      /*
      @param {!CursorPosition} position - cursor position details
      @param {!string} - text where cursor located
      @returns {!int} index of cursor described by provided position.
        If position is out of text's bounds it returns the closest index
      @public
       */

      TextUtils.positionToIdx = function(position, text) {
        var lineIdx, newLineMatch, newLineRx, prevLineStartOffset;
        if ((position == null) || (position.row == null) || (position.column == null)) {
          return 0;
        }
        if (position.row < 0 || position.column < 0) {
          return 0;
        }
        lineIdx = 0;
        prevLineStartOffset = 0;
        newLineRx = /(\n\r?)/gm;
        newLineMatch = newLineRx.exec(text);
        while (newLineMatch !== null) {
          if (lineIdx === position.row) {
            return Math.min(prevLineStartOffset + position.column, text.length);
          }
          prevLineStartOffset = newLineMatch.index + newLineMatch[1].length;
          lineIdx++;
          newLineMatch = newLineRx.exec(text);
        }
        return Math.min(text.length, prevLineStartOffset + position.column);
      };

      return TextUtils;

    })();
    return TextUtils;
  });

}).call(this);
