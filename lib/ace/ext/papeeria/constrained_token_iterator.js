// Generated by CoffeeScript 1.12.6
(function() {
  define(function(require, exports, module) {
    var ConstrainedTokenIterator, Range, TokenIterator;
    TokenIterator = require("ace/token_iterator").TokenIterator;
    Range = require("ace/range").Range;

    /**
     * This class is a wrapper around "ace/token_iterator", limiting token
     * navigation to a given range. It behaves as if it is a regular token
     * iterator within a document, consisting of a text in a given range
     * @class TokenIterator
     */
    ConstrainedTokenIterator = (function() {
      function ConstrainedTokenIterator(session, range, row, column) {
        var curToken, ref, tokenColumn, tokenRange, tokenRow;
        this.session = session;
        this.range = range;
        this.tokenIterator = new TokenIterator(this.session, row, column);
        curToken = this.tokenIterator.getCurrentToken();
        if (curToken == null) {
          this.outOfRange = false;
        }
        ref = this.tokenIterator.getCurrentTokenPosition(), tokenRow = ref.row, tokenColumn = ref.column;
        tokenRange = new Range(tokenRow, tokenColumn, tokenRow, tokenColumn + curToken.value.length);
        this.outOfRange = !this.range.containsRange(tokenRange);
      }

      ConstrainedTokenIterator.prototype.getCurrentToken = function() {
        if (!this.outOfRange) {
          return this.tokenIterator.getCurrentToken();
        } else {
          return null;
        }
      };

      ConstrainedTokenIterator.prototype.getCurrentTokenPosition = function() {
        if (!this.outOfRange) {
          return this.tokenIterator.getCurrentTokenPosition();
        } else {
          return null;
        }
      };

      ConstrainedTokenIterator.prototype.stepBackward = function() {
        var curToken, ref, tokenColumn, tokenRange, tokenRow;
        this.tokenIterator.stepBackward();
        curToken = this.tokenIterator.getCurrentToken();
        if (curToken == null) {
          this.outOfRange = true;
          return null;
        }
        ref = this.tokenIterator.getCurrentTokenPosition(), tokenRow = ref.row, tokenColumn = ref.column;
        tokenRange = new Range(tokenRow, tokenColumn, tokenRow, tokenColumn + curToken.value.length);
        if (this.range.containsRange(tokenRange)) {
          this.outOfRange = false;
          return curToken;
        } else {
          this.outOfRange = true;
          return null;
        }
      };

      ConstrainedTokenIterator.prototype.stepForward = function() {
        var curToken, ref, tokenColumn, tokenRange, tokenRow;
        this.tokenIterator.stepForward();
        curToken = this.tokenIterator.getCurrentToken();
        if (curToken == null) {
          this.outOfRange = true;
          return null;
        }
        ref = this.tokenIterator.getCurrentTokenPosition(), tokenRow = ref.row, tokenColumn = ref.column;
        tokenRange = new Range(tokenRow, tokenColumn, tokenRow, tokenColumn + curToken.value.length);
        if (this.range.containsRange(tokenRange)) {
          this.outOfRange = false;
          return curToken;
        } else {
          this.outOfRange = true;
          return null;
        }
      };

      ConstrainedTokenIterator.prototype.stepTo = function(row, column) {
        this.tokenIterator = new TokenIterator(this.session, row, column);
        return this.outOfRange = !this.range.contains(row, column);
      };

      return ConstrainedTokenIterator;

    })();
    return exports = {
      ConstrainedTokenIterator: ConstrainedTokenIterator
    };
  });

}).call(this);

//# sourceMappingURL=constrained_token_iterator.js.map
