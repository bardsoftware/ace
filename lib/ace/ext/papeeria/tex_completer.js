// Generated by CoffeeScript 1.10.0
(function() {
  var foo,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  foo = null;

  define(function(require, exports, module) {
    var EQUATION_STATE, HashHandler, LIST_STATE, LatexParsingContext, PapeeriaLatexHighlightRules, ReferenceGetter, SumsAndIntegrals, TexCompleter, basicSnippets, env, equationEnvironments, equationSnippets, formulasSnippets, greekLetters, init, isType, listEnvironments, listKeywords, listSnippets;
    HashHandler = require("ace/keyboard/hash_handler");
    PapeeriaLatexHighlightRules = require("ace/ext/papeeria/papeeria_latex_highlight_rules");
    LatexParsingContext = require("ace/ext/papeeria/latex_parsing_context");
    EQUATION_STATE = PapeeriaLatexHighlightRules.EQUATION_STATE;
    LIST_STATE = PapeeriaLatexHighlightRules.LIST_STATE;
    equationEnvironments = ["equation", "equation*"];
    listEnvironments = ["itemize", "enumerate"];
    basicSnippets = [
      {
        caption: "\\ref{...",
        snippet: "\\ref{${1}}",
        meta: "base"
      }, {
        caption: "\\usepackage[]{...",
        snippet: "\\usepackage{${1  :package}}\n",
        meta: "base"
      }, {
        caption: "\\usepackage[options]{...",
        snippet: "\\usepackage[${1:[options}]{${2:package}}\n",
        meta: "base"
      }, {
        caption: "\\newcommand{...",
        snippet: "\\newcommand{${1:cmd}}[${2:opt}]{${3:realcmd}}${0}\n",
        meta: "base"
      }
    ];
    listSnippets = (function() {
      var i, len, results;
      results = [];
      for (i = 0, len = listEnvironments.length; i < len; i++) {
        env = listEnvironments[i];
        results.push({
          caption: "\\begin{" + env + "}...",
          snippet: "\\begin{" + env + "}\n\t\\item $1\n\\end{" + env + "}",
          meta: "list"
        });
      }
      return results;
    })();
    equationSnippets = (function() {
      var i, len, results;
      results = [];
      for (i = 0, len = equationEnvironments.length; i < len; i++) {
        env = equationEnvironments[i];
        results.push({
          caption: "\\begin{" + env + "}...",
          snippet: "\\begin{" + env + "}\n\t$1\n\\end{" + env + "}",
          meta: "equation"
        });
      }
      return results;
    })();
    SumsAndIntegrals = ["\\sum", "\\int", "\\bigcup", "\\bigsqcup", "\\oint", "\\bigotimes", "\\bigcap", "\\bigvee", "\\oint", "\\bigwedge", "\\biguplus", "\\bigodot", "\\coprod", "\\prod"];
    SumsAndIntegrals = SumsAndIntegrals.map(function(word) {
      return {
        caption: word + "{n}{i=..}{..}",
        snippet: word + "^{${1:n}}_{${2:i=1}}{${3}}",
        score: 1,
        meta: "Sums and integrals"
      };
    });
    formulasSnippets = [
      {
        caption: "\\frac{num}{denom}",
        snippet: "\\frac{${1:num}}{${2:denom}}",
        score: 4,
        meta: "Math"
      }, {
        caption: "\\sqrt{n}",
        snippet: "\\sqrt{${1:n}}",
        score: 4,
        meta: "Math"
      }, {
        caption: "\\sqrt[k]{n}",
        snippet: "\\sqrt[${1:k}]{${2:n}}",
        score: 4,
        meta: "Math"
      }, {
        caption: "\\binom{n}{k}",
        snippet: "\\binom{${1:n}}{${2:k}}",
        score: 4,
        meta: "Math"
      }
    ];
    greekLetters = ["\\gamma", "\\delta", "\\theta", "\\lambda", "\\nu", "\\xi", "\\pi", "\\sigma", "\\upsilon", "\\phi", "\\chi", "\\psi", "\\omega"];
    greekLetters = greekLetters.concat(greekLetters.map(function(word) {
      return "\\" + word[1].toUpperCase() + word.substring(2);
    }));
    greekLetters = greekLetters.concat(["\\alpha", "\\beta", "\\chi", "\\nu", "\\eta", "\\zeta", "\\rho", "\\mu", "\\epsilon", "\\iota", "\\kappa", "\\tau", "\\varepsilon", "\\varsigma", "\\varphi", "\\varrho", "\\vartheta", "\\varkappa"]);
    listKeywords = ["\\item"];
    listKeywords = listKeywords.map(function(word) {
      return {
        caption: word,
        value: word,
        meta: "list"
      };
    });
    greekLetters = greekLetters.map(function(word) {
      return {
        caption: word,
        value: word,
        score: 2,
        meta: "Greek Letter"
      };
    });
    isType = function(token, type) {
      return token.type.split(".").indexOf(type) > -1;
    };
    init = function(editor, bindKey) {
      var keyboardHandler;
      keyboardHandler = new HashHandler.HashHandler();
      keyboardHandler.addCommand({
        name: "add item in list mode",
        bindKey: bindKey,
        exec: function(editor) {
          var cursor, indentString, indexOfBegin, line, tabString;
          cursor = editor.getCursorPosition();
          line = editor.session.getLine(cursor.row);
          tabString = editor.session.getTabString();
          indentString = line.match(/^\s*/)[0];
          indexOfBegin = line.indexOf("begin");
          if (LatexParsingContext.getContext(editor.session, cursor.row) === LIST_STATE && indexOfBegin < cursor.column) {
            if (indexOfBegin > -1) {
              editor.insert("\n" + tabString + indentString + "\\item ");
            } else {
              editor.insert("\n" + indentString + "\\item ");
            }
            return true;
          } else {
            return false;
          }
        }
      });
      return editor.keyBinding.addKeyboardHandler(keyboardHandler);
    };
    ReferenceGetter = (function() {
      function ReferenceGetter() {
        this.getReferences = bind(this.getReferences, this);
        this.processData = bind(this.processData, this);
        this.lastFetchedUrl = "";
        this.cache = [];
      }

      ReferenceGetter.prototype.processData = function(data) {
        var ref;
        return this.cache = (ref = data.Labels) != null ? ref.map((function(_this) {
          return function(elem) {
            return {
              name: elem.caption,
              value: elem.caption,
              meta: elem.type + "-ref"
            };
          };
        })(this)) : void 0;
      };

      ReferenceGetter.prototype.getReferences = function(url, callback) {
        if (url !== this.lastFetchedUrl) {
          return $.getJSON(url).done((function(_this) {
            return function(data) {
              _this.processData(data);
              callback(null, _this.cache);
              return _this.lastFetchedUrl = url;
            };
          })(this));
        } else {
          return callback(null, this.cache);
        }
      };

      return ReferenceGetter;

    })();
    TexCompleter = (function() {
      function TexCompleter() {
        this.getCompletions = bind(this.getCompletions, this);
        this.setReferencesUrl = bind(this.setReferencesUrl, this);
        this.refGetter = new ReferenceGetter();
      }

      TexCompleter.init = function(editor) {
        return init(editor, {
          win: "enter",
          mac: "enter"
        });
      };

      TexCompleter.prototype.setReferencesUrl = function(url) {
        return this.referencesUrl = url;
      };


      /*
       * callback -- this function is adding list of completions to our popup. Provide by ACE completions API
       * @param {object} error -- convention in node, the first argument to a callback
       * is usually used to indicate an error
       * @param {array} response -- list of completions for adding to popup
       */

      TexCompleter.prototype.getCompletions = function(editor, session, pos, prefix, callback) {
        var context, token;
        context = LatexParsingContext.getContext(session, pos.row);
        token = session.getTokenAt(pos.row, pos.column);
        if (isType(token, "ref") && (this.referencesUrl != null)) {
          return this.refGetter.getReferences(this.referencesUrl, callback);
        } else {
          switch (context) {
            case "start":
              return callback(null, listSnippets.concat(equationSnippets.concat(basicSnippets)));
            case LIST_STATE:
              return callback(null, listKeywords.concat(listSnippets.concat(equationSnippets)));
            case EQUATION_STATE:
              return callback(null, SumsAndIntegrals.concat(formulasSnippets.concat(greekLetters)));
          }
        }
      };

      return TexCompleter;

    })();
    return TexCompleter;
  });

}).call(this);
