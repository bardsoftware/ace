// Generated by CoffeeScript 1.10.0
(function() {
  var foo,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  foo = null;

  define(function(require, exports, module) {
    var BASIC_SNIPPETS, CITATION_SNIPPET, CompletionsCache, EQUATION_ENVIRONMENTS, EQUATION_ENV_SNIPPETS, EQUATION_SNIPPETS, EQUATION_STATE, HashHandler, LIST_END_ENVIRONMENT, LIST_ENVIRONMENTS, LIST_KEYWORDS, LIST_SNIPPET, LIST_STATE, LatexParsingContext, PapeeriaLatexHighlightRules, REFERENCE_SNIPPET, TexCompleter, compare, env, init, processCitationJson, processReferenceJson, showPopupIfTokenIsOneOfTypes;
    HashHandler = require("ace/keyboard/hash_handler");
    PapeeriaLatexHighlightRules = require("ace/ext/papeeria/papeeria_latex_highlight_rules");
    LatexParsingContext = require("ace/ext/papeeria/latex_parsing_context");
    EQUATION_STATE = PapeeriaLatexHighlightRules.EQUATION_STATE;
    LIST_STATE = PapeeriaLatexHighlightRules.LIST_STATE;
    EQUATION_SNIPPETS = require("./snippets/equation_snippets");
    LIST_ENVIRONMENTS = ["itemize", "enumerate"];
    EQUATION_ENVIRONMENTS = ["equation", "equation*"];
    EQUATION_ENV_SNIPPETS = (function() {
      var i, len, results;
      results = [];
      for (i = 0, len = EQUATION_ENVIRONMENTS.length; i < len; i++) {
        env = EQUATION_ENVIRONMENTS[i];
        results.push({
          caption: "\\begin{" + env + "}...",
          snippet: "\\begin{" + env + "}\n\t$1\n\\end{" + env + "}",
          meta: "equation",
          meta_score: 10
        });
      }
      return results;
    })();
    LIST_END_ENVIRONMENT = (function() {
      var i, len, results;
      results = [];
      for (i = 0, len = LIST_ENVIRONMENTS.length; i < len; i++) {
        env = LIST_ENVIRONMENTS[i];
        results.push({
          caption: "\\end{" + env + "}",
          value: "\\end{" + env + "}",
          score: 0,
          meta: "End",
          meta_score: 1
        });
      }
      return results;
    })();
    REFERENCE_SNIPPET = {
      caption: "\\ref{...",
      snippet: "\\ref{${1}}",
      meta: "reference and citation",
      meta_score: 10
    };
    CITATION_SNIPPET = {
      caption: "\\cite{...",
      snippet: "\\cite{${1}}",
      meta: "reference and citation",
      meta_score: 10
    };
    compare = function(a, b) {
      return a.caption.localeCompare(b.caption);
    };
    BASIC_SNIPPETS = [
      {
        caption: "\\usepackage[]{...",
        snippet: "\\usepackage{${1  :package}}\n",
        meta: "base",
        meta_score: 9
      }, {
        caption: "\\usepackage[options]{...",
        snippet: "\\usepackage[${1:[options}]{${2:package}}\n",
        meta: "base",
        meta_score: 9
      }, {
        caption: "\\newcommand{...",
        snippet: "\\newcommand{${1:cmd}}[${2:opt}]{${3:realcmd}}${0}\n",
        meta: "base",
        meta_score: 9
      }
    ];
    BASIC_SNIPPETS = BASIC_SNIPPETS.sort(compare);
    LIST_SNIPPET = (function() {
      var i, len, results;
      results = [];
      for (i = 0, len = LIST_ENVIRONMENTS.length; i < len; i++) {
        env = LIST_ENVIRONMENTS[i];
        results.push({
          caption: "\\begin{" + env + "}...",
          snippet: "\\begin{" + env + "}\n\t\\item $1\n\\end{" + env + "}",
          meta: "list",
          meta_score: 10
        });
      }
      return results;
    })();
    LIST_KEYWORDS = ["\\item"];
    LIST_KEYWORDS = LIST_KEYWORDS.map(function(word) {
      return {
        caption: word,
        value: word,
        meta: "list",
        meta_score: 10
      };
    });
    init = function(editor, bindKey) {
      var keyboardHandler;
      keyboardHandler = new HashHandler.HashHandler();
      keyboardHandler.addCommand({
        name: "add item in list mode",
        bindKey: bindKey,
        exec: function(editor) {
          var cursor, indentString, indexOfBegin, line, tabString;
          cursor = editor.getCursorPosition();
          line = editor.session.getLine(cursor.row);
          tabString = editor.session.getTabString();
          indentString = line.match(/^\s*/)[0];
          indexOfBegin = line.indexOf("begin");
          if (LatexParsingContext.getContext(editor.session, cursor.row, cursor.column) === LIST_STATE && indexOfBegin < cursor.column) {
            if (indexOfBegin > -1) {
              editor.insert("\n" + tabString + indentString + "\\item ");
            } else {
              editor.insert("\n" + indentString + "\\item ");
            }
            return true;
          } else {
            return false;
          }
        }
      });
      return editor.keyBinding.addKeyboardHandler(keyboardHandler);
    };
    processReferenceJson = (function(_this) {
      return function(elem) {
        return {
          name: elem.caption,
          value: elem.caption,
          score: 1000,
          meta: elem.type,
          meta_score: 10
        };
      };
    })(this);
    processCitationJson = (function(_this) {
      return function(elem) {
        return {
          name: elem.id,
          value: elem.id,
          score: 1000,
          meta: elem.type,
          meta_score: 10
        };
      };
    })(this);
    CompletionsCache = (function() {

      /*
      * processJson -- function -- handler for defined type of json(citeJson, refJson, etc)
      * return object with fields name, value and (optional) meta, meta_score, score
       */
      function CompletionsCache(processJson) {
        this.getReferences = bind(this.getReferences, this);
        this.processData = bind(this.processData, this);
        this.lastFetchedUrl = "";
        this.cache = [];
        this.processJson = processJson;
      }

      CompletionsCache.prototype.processData = function(data) {
        return this.cache = data != null ? data.map(this.processJson) : void 0;
      };

      CompletionsCache.prototype.getReferences = function(url, callback) {
        if (url !== this.lastFetchedUrl) {
          return $.getJSON(url).done((function(_this) {
            return function(data) {
              _this.processData(data);
              callback(null, _this.cache);
              return _this.lastFetchedUrl = url;
            };
          })(this));
        } else {
          return callback(null, this.cache);
        }
      };

      return CompletionsCache;

    })();

    /*
    * Show popup if token type at the current pos is one of the given array elements.
    * @ (editor) --> editor
    * @ (list of strings) -- allowedTypes
     */
    showPopupIfTokenIsOneOfTypes = function(editor, allowedTypes) {
      var i, len, pos, results, session, token, type;
      if (editor.completer != null) {
        pos = editor.getCursorPosition();
        session = editor.getSession();
        token = editor.session.getTokenAt(pos.row, pos.column);
        if (token != null) {
          results = [];
          for (i = 0, len = allowedTypes.length; i < len; i++) {
            type = allowedTypes[i];
            if (LatexParsingContext.isType(token, type)) {
              editor.completer.showPopup(editor);
              break;
            } else {
              results.push(void 0);
            }
          }
          return results;
        }
      }
    };
    TexCompleter = (function() {
      function TexCompleter() {
        this.getCompletions = bind(this.getCompletions, this);
        this.setCitationsUrl = bind(this.setCitationsUrl, this);
        this.setReferencesUrl = bind(this.setReferencesUrl, this);
        this.refCache = new CompletionsCache(processReferenceJson);
        this.citeCache = new CompletionsCache(processCitationJson);
      }

      TexCompleter.init = function(editor) {
        init(editor, {
          win: "enter",
          mac: "enter"
        });
        editor.commands.on('afterExec', function(event) {
          var allowCommand, ref;
          allowCommand = ["Return", "backspace"];
          if (ref = event.command.name, indexOf.call(allowCommand, ref) >= 0) {
            return showPopupIfTokenIsOneOfTypes(editor, ["ref", "cite"]);
          }
        });
        return editor.getSession().selection.on('changeCursor', function(cursorEvent) {
          return showPopupIfTokenIsOneOfTypes(editor, ["ref", "cite"]);
        });
      };

      TexCompleter.prototype.setReferencesUrl = function(url) {
        return this.referencesUrl = url;
      };

      TexCompleter.prototype.setCitationsUrl = function(url) {
        return this.citationsUrl = url;
      };


      /*
       * callback -- this function is adding list of completions to our popup. Provide by ACE completions API
       * @param {object} error -- convention in node, the first argument to a callback
       * is usually used to indicate an error
       * @param {array} response -- list of completions for adding to popup
       */

      TexCompleter.prototype.getCompletions = function(editor, session, pos, prefix, callback) {
        var context, token;
        token = session.getTokenAt(pos.row, pos.column);
        context = LatexParsingContext.getContext(session, pos.row, pos.column);
        if (LatexParsingContext.isType(token, "ref")) {
          if (this.referencesUrl != null) {
            return this.refCache.getReferences(this.referencesUrl, callback);
          }
        } else if (LatexParsingContext.isType(token, "cite")) {
          if (this.citationsUrl != null) {
            return this.citeCache.getReferences(this.citationsUrl, callback);
          }
        } else {
          switch (context) {
            case "start":
              return callback(null, BASIC_SNIPPETS.concat(LIST_SNIPPET, EQUATION_ENV_SNIPPETS, REFERENCE_SNIPPET, CITATION_SNIPPET));
            case LIST_STATE:
              return callback(null, LIST_KEYWORDS.concat(LIST_SNIPPET, EQUATION_ENV_SNIPPETS, REFERENCE_SNIPPET, CITATION_SNIPPET, LIST_END_ENVIRONMENT));
            case EQUATION_STATE:
              return callback(null, EQUATION_SNIPPETS);
          }
        }
      };

      return TexCompleter;

    })();
    return TexCompleter;
  });

}).call(this);
