// Generated by CoffeeScript 1.12.6
(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  define(function(require, exports, module) {
    var AUTO_INSERT, Behaviour, COMMENT_REGEX, DO_NOTHING, EQUATION_REGEX, ESCAPE_REGEX, LatexBehaviour, MATH_REGEX, RPAREN_REGEX, SKIP, SKIP_TWO, correspondingClosing, dollarsDeletionAction, dollarsInsertionAction, getBracketInsertionAction, getBracketsDeletionAction, getWrapped, isCommentToken, isEscapedInsertion, isInEquation;
    Behaviour = require("ace/mode/behaviour").Behaviour;
    COMMENT_REGEX = /comment/;
    ESCAPE_REGEX = /escape/;
    MATH_REGEX = /math/;
    EQUATION_REGEX = /equation/;
    RPAREN_REGEX = /rparen/;
    correspondingClosing = {
      '(': ')',
      '[': ']',
      '{': '}'
    };
    isCommentToken = function(token, column) {
      return (token != null) && COMMENT_REGEX.test(token.type) && column !== 0;
    };
    isEscapedInsertion = function(token, column) {
      return (token != null) && ESCAPE_REGEX.test(token.type) && column - token.start === 1;
    };
    isInEquation = function(session, row, column) {
      var lastPrevState, lastState, nextToken, pState, state, token;
      token = session.getTokenAt(row, column);
      nextToken = session.getTokenAt(row, column + 1);
      state = session.getState(row);
      pState = session.getState(row - 1);
      lastState = typeof state === "string" ? state : state[state.length - 1];
      lastPrevState = typeof pState === "string" ? pState : pState[pState.length - 1];
      return ((token == null) && MATH_REGEX.test(lastPrevState)) || ((token != null) && EQUATION_REGEX.test(token.type)) || ((nextToken != null) && EQUATION_REGEX.test(nextToken.type));
    };
    DO_NOTHING = null;
    AUTO_INSERT = {
      text: "$$",
      selection: [1, 1]
    };
    SKIP = {
      text: "",
      selection: [1, 1]
    };
    dollarsInsertionAction = function(state, action, editor, session, text) {
      var column, line, nextChar, nextToken, prevChar, ref, row, selected, selection, shouldSkip, token;
      if (text === '$' && !editor.inMultiSelectMode) {
        ref = editor.getCursorPosition(), row = ref.row, column = ref.column;
        line = session.getLine(row);
        selection = editor.getSelectionRange();
        selected = session.getTextRange(selection);
        if (selected !== "") {
          if (editor.getWrapBehavioursEnabled()) {
            return getWrapped(selection, selected, text, text);
          } else {
            return DO_NOTHING;
          }
        }
        token = session.getTokenAt(row, column);
        nextToken = session.getTokenAt(row, column + 1);
        if (isCommentToken(token, column) || isEscapedInsertion(token, column)) {
          return DO_NOTHING;
        }
        prevChar = line[column - 1] || '';
        nextChar = line[column] || '';
        if (isInEquation(session, row, column)) {
          if (nextChar === '$') {
            return SKIP;
          } else {
            return DO_NOTHING;
          }
        }
        shouldSkip = nextChar === '$' && (prevChar !== '$' || RPAREN_REGEX.test(nextToken.type));
        if (shouldSkip) {
          return SKIP;
        } else {
          return AUTO_INSERT;
        }
      }
    };
    dollarsDeletionAction = function(state, action, editor, session, range) {
      var line, nextChar, selected, token;
      selected = session.doc.getTextRange(range);
      if (range.isMultiLine() || selected !== '$') {
        return DO_NOTHING;
      }
      line = session.getLine(range.start.row);
      token = session.getTokenAt(range.end.row, range.end.column);
      nextChar = line[range.start.column + 1];
      if (nextChar === '$' && !ESCAPE_REGEX.test(token.type)) {
        range.end.column++;
        return range;
      }
    };
    getWrapped = function(selection, selected, opening, closing) {
      var rowDiff;
      rowDiff = selection.end.row - selection.start.row;
      return {
        text: opening + selected + closing,
        selection: [0, selection.start.column + 1, rowDiff, selection.end.column + (rowDiff !== 0 ? 0 : 1)]
      };
    };
    SKIP_TWO = {
      text: "",
      selection: [2, 2]
    };
    getBracketInsertionAction = function(opening) {
      var closing;
      closing = correspondingClosing[opening];
      return function(state, action, editor, session, text) {
        var column, line, matching, nextChar, nextToken, ref, ref1, row, selected, selection, shouldComplete, token;
        if (editor.inMultiSelectMode) {
          return DO_NOTHING;
        }
        ref = editor.getCursorPosition(), row = ref.row, column = ref.column;
        line = session.getLine(row);
        switch (text) {
          case opening:
            selection = editor.getSelectionRange();
            selected = session.getTextRange(selection);
            if (selected !== "") {
              if (editor.getWrapBehavioursEnabled()) {
                return getWrapped(selection, selected, opening, closing);
              } else {
                return DO_NOTHING;
              }
            }
            token = session.getTokenAt(row, column);
            if (isEscapedInsertion(token, column)) {
              shouldComplete = opening !== '{' && !isInEquation(session, row, column);
              if (shouldComplete) {
                return {
                  text: opening + '\\' + closing,
                  selection: [1, 1]
                };
              } else {
                return DO_NOTHING;
              }
            }
            if (!((ref1 = editor.completer) != null ? ref1.activated : void 0) && !isCommentToken(token, column)) {
              return {
                text: opening + closing,
                selection: [1, 1]
              };
            }
            break;
          case closing:
            nextChar = line[column];
            if (nextChar === closing) {
              matching = session.$findOpeningBracket(closing, {
                column: column + 1,
                row: row
              });
              if (matching != null) {
                return SKIP;
              } else {
                return DO_NOTHING;
              }
            }
            if (opening === '{') {
              return DO_NOTHING;
            }
            nextToken = session.getTokenAt(row, column + 1);
            if (nextChar === "\\" && line[column + 1] === closing && RPAREN_REGEX.test(nextToken.type)) {
              return SKIP_TWO;
            }
        }
      };
    };
    getBracketsDeletionAction = function(opening) {
      var closing;
      closing = correspondingClosing[opening];
      return function(state, action, editor, session, range) {
        var column, line, nextChar, nextNextChar, prevChar, ref, row, selected;
        if (range.isMultiLine()) {
          return DO_NOTHING;
        }
        selected = session.doc.getTextRange(range);
        if (selected !== opening) {
          return DO_NOTHING;
        }
        ref = range.start, row = ref.row, column = ref.column;
        line = session.doc.getLine(row);
        nextChar = line[column + 1];
        if (nextChar === closing) {
          range.end.column += 1;
          return range;
        }
        if (opening === '{') {
          return DO_NOTHING;
        }
        prevChar = line[column - 1];
        nextNextChar = line[column + 2];
        if (prevChar === '\\' && nextChar === '\\' && nextNextChar === closing) {
          range.end.column += 2;
          return range;
        }
      };
    };
    LatexBehaviour = (function(superClass) {
      extend(LatexBehaviour, superClass);

      function LatexBehaviour() {
        this.add("dollars", "insertion", dollarsInsertionAction);
        this.add("dollars", "deletion", dollarsDeletionAction);
        this.add("braces", "insertion", getBracketInsertionAction('{'));
        this.add("braces", "deletion", getBracketsDeletionAction('{'));
        this.add("parens", "insertion", getBracketInsertionAction('('));
        this.add("parens", "deletion", getBracketsDeletionAction('('));
        this.add("brackets", "insertion", getBracketInsertionAction('['));
        this.add("brackets", "deletion", getBracketsDeletionAction('['));
      }

      return LatexBehaviour;

    })(Behaviour);
    exports.LatexBehaviour = LatexBehaviour;
  });

}).call(this);

//# sourceMappingURL=latex_behaviour.js.map
